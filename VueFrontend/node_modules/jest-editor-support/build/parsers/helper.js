"use strict";

require("core-js/modules/es.array.is-array.js");

require("core-js/modules/es.symbol.js");

require("core-js/modules/es.symbol.description.js");

require("core-js/modules/es.object.to-string.js");

require("core-js/modules/es.symbol.iterator.js");

require("core-js/modules/es.array.iterator.js");

require("core-js/modules/es.string.iterator.js");

require("core-js/modules/web.dom-collections.iterator.js");

require("core-js/modules/es.array.from.js");

require("core-js/modules/es.array.slice.js");

require("core-js/modules/es.function.name.js");

require("core-js/modules/es.object.define-property.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.parseOptions = exports.tsxPlugins = exports.tsPlugins = exports.jsPlugins = void 0;

require("core-js/modules/es.array.concat.js");

require("core-js/modules/es.regexp.exec.js");

require("core-js/modules/es.string.match.js");

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

/**
 * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */
var commonPlugins = ['asyncGenerators', 'bigInt', 'classPrivateMethods', 'classPrivateProperties', 'classProperties', 'doExpressions', 'dynamicImport', 'estree', 'exportDefaultFrom', 'exportNamespaceFrom', // deprecated
'functionBind', 'functionSent', 'importMeta', 'logicalAssignment', 'nullishCoalescingOperator', 'numericSeparator', 'objectRestSpread', 'optionalCatchBinding', 'optionalChaining', 'partialApplication', 'throwExpressions', 'topLevelAwait', ['decorators', {
  decoratorsBeforeExport: true
}], ['pipelineOperator', {
  proposal: 'smart'
}]];
var jsPlugins = [].concat(commonPlugins, ['flow', 'jsx']);
exports.jsPlugins = jsPlugins;
var tsPlugins = [].concat(commonPlugins, ['typescript']);
exports.tsPlugins = tsPlugins;
var tsxPlugins = [].concat(commonPlugins, ['typescript', 'jsx']);
exports.tsxPlugins = tsxPlugins;

var parseOptions = function parseOptions(filePath) {
  var strictMode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

  if (filePath.match(/\.ts$/i)) {
    return {
      plugins: _toConsumableArray(tsPlugins)
    };
  }

  if (filePath.match(/\.tsx$/i)) {
    return {
      plugins: _toConsumableArray(tsxPlugins)
    };
  } // for backward compatibility, use js parser as default unless in strict mode


  if (!strictMode || filePath.match(/\.m?jsx?$/i)) {
    return {
      plugins: _toConsumableArray(jsPlugins)
    };
  }

  throw new TypeError("unable to find parser options for unrecognized file extension: ".concat(filePath));
};

exports.parseOptions = parseOptions;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9wYXJzZXJzL2hlbHBlci50cyJdLCJuYW1lcyI6WyJjb21tb25QbHVnaW5zIiwiZGVjb3JhdG9yc0JlZm9yZUV4cG9ydCIsInByb3Bvc2FsIiwianNQbHVnaW5zIiwidHNQbHVnaW5zIiwidHN4UGx1Z2lucyIsInBhcnNlT3B0aW9ucyIsImZpbGVQYXRoIiwic3RyaWN0TW9kZSIsIm1hdGNoIiwicGx1Z2lucyIsIlR5cGVFcnJvciJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUEsSUFBTUEsYUFBNkIsR0FBRyxDQUNwQyxpQkFEb0MsRUFFcEMsUUFGb0MsRUFHcEMscUJBSG9DLEVBSXBDLHdCQUpvQyxFQUtwQyxpQkFMb0MsRUFNcEMsZUFOb0MsRUFPcEMsZUFQb0MsRUFRcEMsUUFSb0MsRUFTcEMsbUJBVG9DLEVBVXBDLHFCQVZvQyxFQVViO0FBQ3ZCLGNBWG9DLEVBWXBDLGNBWm9DLEVBYXBDLFlBYm9DLEVBY3BDLG1CQWRvQyxFQWVwQywyQkFmb0MsRUFnQnBDLGtCQWhCb0MsRUFpQnBDLGtCQWpCb0MsRUFrQnBDLHNCQWxCb0MsRUFtQnBDLGtCQW5Cb0MsRUFvQnBDLG9CQXBCb0MsRUFxQnBDLGtCQXJCb0MsRUFzQnBDLGVBdEJvQyxFQXVCcEMsQ0FBQyxZQUFELEVBQWU7QUFBQ0MsRUFBQUEsc0JBQXNCLEVBQUU7QUFBekIsQ0FBZixDQXZCb0MsRUF3QnBDLENBQUMsa0JBQUQsRUFBcUI7QUFBQ0MsRUFBQUEsUUFBUSxFQUFFO0FBQVgsQ0FBckIsQ0F4Qm9DLENBQXRDO0FBMkJPLElBQU1DLFNBQXlCLGFBQU9ILGFBQVAsR0FBc0IsTUFBdEIsRUFBOEIsS0FBOUIsRUFBL0I7O0FBQ0EsSUFBTUksU0FBeUIsYUFBT0osYUFBUCxHQUFzQixZQUF0QixFQUEvQjs7QUFDQSxJQUFNSyxVQUEwQixhQUFPTCxhQUFQLEdBQXNCLFlBQXRCLEVBQW9DLEtBQXBDLEVBQWhDOzs7QUFFQSxJQUFNTSxZQUFZLEdBQUcsU0FBZkEsWUFBZSxDQUFDQyxRQUFELEVBQXlEO0FBQUEsTUFBdENDLFVBQXNDLHVFQUF6QixLQUF5Qjs7QUFDbkYsTUFBSUQsUUFBUSxDQUFDRSxLQUFULENBQWUsUUFBZixDQUFKLEVBQThCO0FBQzVCLFdBQU87QUFBQ0MsTUFBQUEsT0FBTyxxQkFBTU4sU0FBTjtBQUFSLEtBQVA7QUFDRDs7QUFFRCxNQUFJRyxRQUFRLENBQUNFLEtBQVQsQ0FBZSxTQUFmLENBQUosRUFBK0I7QUFDN0IsV0FBTztBQUFDQyxNQUFBQSxPQUFPLHFCQUFNTCxVQUFOO0FBQVIsS0FBUDtBQUNELEdBUGtGLENBU25GOzs7QUFDQSxNQUFJLENBQUNHLFVBQUQsSUFBZUQsUUFBUSxDQUFDRSxLQUFULENBQWUsWUFBZixDQUFuQixFQUFpRDtBQUMvQyxXQUFPO0FBQUNDLE1BQUFBLE9BQU8scUJBQU1QLFNBQU47QUFBUixLQUFQO0FBQ0Q7O0FBRUQsUUFBTSxJQUFJUSxTQUFKLDBFQUFnRkosUUFBaEYsRUFBTjtBQUNELENBZk0iLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNC1wcmVzZW50LCBGYWNlYm9vaywgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG5pbXBvcnQge1BhcnNlck9wdGlvbnMsIFBhcnNlclBsdWdpbn0gZnJvbSAnQGJhYmVsL3BhcnNlcic7XG5cbmNvbnN0IGNvbW1vblBsdWdpbnM6IFBhcnNlclBsdWdpbltdID0gW1xuICAnYXN5bmNHZW5lcmF0b3JzJyxcbiAgJ2JpZ0ludCcsXG4gICdjbGFzc1ByaXZhdGVNZXRob2RzJyxcbiAgJ2NsYXNzUHJpdmF0ZVByb3BlcnRpZXMnLFxuICAnY2xhc3NQcm9wZXJ0aWVzJyxcbiAgJ2RvRXhwcmVzc2lvbnMnLFxuICAnZHluYW1pY0ltcG9ydCcsXG4gICdlc3RyZWUnLFxuICAnZXhwb3J0RGVmYXVsdEZyb20nLFxuICAnZXhwb3J0TmFtZXNwYWNlRnJvbScsIC8vIGRlcHJlY2F0ZWRcbiAgJ2Z1bmN0aW9uQmluZCcsXG4gICdmdW5jdGlvblNlbnQnLFxuICAnaW1wb3J0TWV0YScsXG4gICdsb2dpY2FsQXNzaWdubWVudCcsXG4gICdudWxsaXNoQ29hbGVzY2luZ09wZXJhdG9yJyxcbiAgJ251bWVyaWNTZXBhcmF0b3InLFxuICAnb2JqZWN0UmVzdFNwcmVhZCcsXG4gICdvcHRpb25hbENhdGNoQmluZGluZycsXG4gICdvcHRpb25hbENoYWluaW5nJyxcbiAgJ3BhcnRpYWxBcHBsaWNhdGlvbicsXG4gICd0aHJvd0V4cHJlc3Npb25zJyxcbiAgJ3RvcExldmVsQXdhaXQnLFxuICBbJ2RlY29yYXRvcnMnLCB7ZGVjb3JhdG9yc0JlZm9yZUV4cG9ydDogdHJ1ZX1dLFxuICBbJ3BpcGVsaW5lT3BlcmF0b3InLCB7cHJvcG9zYWw6ICdzbWFydCd9XSxcbl07XG5cbmV4cG9ydCBjb25zdCBqc1BsdWdpbnM6IFBhcnNlclBsdWdpbltdID0gWy4uLmNvbW1vblBsdWdpbnMsICdmbG93JywgJ2pzeCddO1xuZXhwb3J0IGNvbnN0IHRzUGx1Z2luczogUGFyc2VyUGx1Z2luW10gPSBbLi4uY29tbW9uUGx1Z2lucywgJ3R5cGVzY3JpcHQnXTtcbmV4cG9ydCBjb25zdCB0c3hQbHVnaW5zOiBQYXJzZXJQbHVnaW5bXSA9IFsuLi5jb21tb25QbHVnaW5zLCAndHlwZXNjcmlwdCcsICdqc3gnXTtcblxuZXhwb3J0IGNvbnN0IHBhcnNlT3B0aW9ucyA9IChmaWxlUGF0aDogc3RyaW5nLCBzdHJpY3RNb2RlID0gZmFsc2UpOiBQYXJzZXJPcHRpb25zID0+IHtcbiAgaWYgKGZpbGVQYXRoLm1hdGNoKC9cXC50cyQvaSkpIHtcbiAgICByZXR1cm4ge3BsdWdpbnM6IFsuLi50c1BsdWdpbnNdfTtcbiAgfVxuXG4gIGlmIChmaWxlUGF0aC5tYXRjaCgvXFwudHN4JC9pKSkge1xuICAgIHJldHVybiB7cGx1Z2luczogWy4uLnRzeFBsdWdpbnNdfTtcbiAgfVxuXG4gIC8vIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCB1c2UganMgcGFyc2VyIGFzIGRlZmF1bHQgdW5sZXNzIGluIHN0cmljdCBtb2RlXG4gIGlmICghc3RyaWN0TW9kZSB8fCBmaWxlUGF0aC5tYXRjaCgvXFwubT9qc3g/JC9pKSkge1xuICAgIHJldHVybiB7cGx1Z2luczogWy4uLmpzUGx1Z2luc119O1xuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihgdW5hYmxlIHRvIGZpbmQgcGFyc2VyIG9wdGlvbnMgZm9yIHVucmVjb2duaXplZCBmaWxlIGV4dGVuc2lvbjogJHtmaWxlUGF0aH1gKTtcbn07XG4iXX0=