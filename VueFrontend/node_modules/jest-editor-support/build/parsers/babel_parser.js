"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

require("core-js/modules/es.object.define-property.js");

require("core-js/modules/es.object.keys.js");

require("core-js/modules/es.symbol.js");

require("core-js/modules/es.object.get-own-property-descriptor.js");

require("core-js/modules/es.object.get-own-property-descriptors.js");

require("core-js/modules/es.object.define-properties.js");

require("core-js/modules/es.symbol.description.js");

require("core-js/modules/es.symbol.iterator.js");

require("core-js/modules/es.array.iterator.js");

require("core-js/modules/es.string.iterator.js");

require("core-js/modules/web.dom-collections.iterator.js");

require("core-js/modules/es.array.slice.js");

require("core-js/modules/es.array.from.js");

require("core-js/modules/es.weak-map.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.parse = exports.getASTfor = void 0;

require("core-js/modules/es.date.to-string.js");

require("core-js/modules/es.object.to-string.js");

require("core-js/modules/es.regexp.to-string.js");

require("core-js/modules/es.array.reduce.js");

require("core-js/modules/es.function.name.js");

require("core-js/modules/es.array.is-array.js");

require("core-js/modules/es.array.for-each.js");

require("core-js/modules/web.dom-collections.for-each.js");

require("core-js/modules/es.array.filter.js");

var _fs = require("fs");

var _types = require("@babel/types");

var parser = _interopRequireWildcard(require("@babel/parser"));

var _parser_nodes = require("./parser_nodes");

var _helper = require("./helper");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var _getASTfor = function _getASTfor(file, data, options) {
  var _data = data || (0, _fs.readFileSync)(file).toString();

  var config = _objectSpread(_objectSpread({}, options), {}, {
    sourceType: 'module'
  });

  return [parser.parse(_data, config), _data];
};

var getASTfor = function getASTfor(file, data) {
  var _getASTfor2 = _getASTfor(file, data, (0, _helper.parseOptions)(file)),
      _getASTfor3 = _slicedToArray(_getASTfor2, 1),
      bFile = _getASTfor3[0];

  return bFile;
};

exports.getASTfor = getASTfor;

var parse = function parse(file, data, options) {
  var parseResult = new _parser_nodes.ParseResult(file);

  var _getASTfor4 = _getASTfor(file, data, options),
      _getASTfor5 = _slicedToArray(_getASTfor4, 2),
      ast = _getASTfor5[0],
      _data = _getASTfor5[1];

  var deepGet = function deepGet(node) {
    for (var _len = arguments.length, types = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      types[_key - 1] = arguments[_key];
    }

    return types.reduce(function (rootForType, type) {
      while (rootForType[type]) {
        rootForType = rootForType[type];
      }

      return rootForType;
    }, node);
  };

  var updateNameInfo = function updateNameInfo(nBlock, bNode, lastProperty) {
    var arg = bNode.expression.arguments[0];
    var name = arg.value;

    if (!name) {
      switch (arg.type) {
        case 'TemplateLiteral':
          name = _data.substring(arg.start + 1, arg.end - 1);
          break;

        default:
          name = _data.substring(arg.start, arg.end);
          break;
      }
    }

    nBlock.name = name;
    nBlock.nameType = arg.type;
    nBlock.lastProperty = lastProperty;
    nBlock.nameRange = new _parser_nodes.ParsedRange(arg.loc.start.line, arg.loc.start.column + 2, arg.loc.end.line, arg.loc.end.column - 1);
  };

  var updateNode = function updateNode(node, babylonNode, lastProperty) {
    node.start = babylonNode.loc.start;
    node.end = babylonNode.loc.end;
    node.start.column += 1;
    parseResult.addNode(node);

    if (node instanceof _parser_nodes.NamedBlock) {
      updateNameInfo(node, babylonNode, lastProperty);
    }
  };

  var isFunctionCall = function isFunctionCall(node) {
    return node && node.type === 'ExpressionStatement' && node.expression && node.expression.type === 'CallExpression';
  };

  var isFunctionDeclaration = function isFunctionDeclaration(nodeType) {
    return nodeType === 'ArrowFunctionExpression' || nodeType === 'FunctionExpression';
  }; // Pull out the name of a CallExpression (describe/it) and the last property (each, skip etc)


  var getNameForNode = function getNameForNode(node) {
    if (isFunctionCall(node) && node.expression.callee) {
      var _rootCallee$property, _deepGet$property;

      // Get root callee in case it's a chain of higher-order functions (e.g. .each(table)(name, fn))
      var rootCallee = deepGet(node.expression, 'callee');
      var property = ((_rootCallee$property = rootCallee.property) === null || _rootCallee$property === void 0 ? void 0 : _rootCallee$property.name) || ((_deepGet$property = deepGet(rootCallee, 'tag').property) === null || _deepGet$property === void 0 ? void 0 : _deepGet$property.name);
      var name = rootCallee.name || // handle cases where it's a member expression (e.g .only or .concurrent.only)
      deepGet(rootCallee, 'object').name || // handle cases where it's part of a tag (e.g. .each`table`)
      deepGet(rootCallee, 'tag', 'object').name;
      return [name, property];
    }

    return [];
  }; // When given a node in the AST, does this represent
  // the start of an it/test block?


  var isAnIt = function isAnIt(name) {
    return name === 'it' || name === 'fit' || name === 'test';
  };

  var isAnDescribe = function isAnDescribe(name) {
    return name === 'describe';
  }; // When given a node in the AST, does this represent
  // the start of an expect expression?


  var isAnExpect = function isAnExpect(node) {
    if (!isFunctionCall(node)) {
      return false;
    }

    var name = '';
    var element = node && node.expression ? node.expression.callee : undefined;

    while (!name && element) {
      // eslint-disable-next-line prefer-destructuring
      name = element.name; // Because expect may have accessors tacked on (.to.be) or nothing
      // (expect()) we have to check multiple levels for the name

      element = element.object || element.callee;
    }

    return name === 'expect';
  };

  var addNode = function addNode(type, parent, babylonNode, lastProperty) {
    var child = parent.addChild(type);
    updateNode(child, babylonNode, lastProperty);

    if (child instanceof _parser_nodes.NamedBlock && child.name == null) {
      // eslint-disable-next-line no-console
      console.warn("block is missing name: ".concat(JSON.stringify(babylonNode)));
    }

    return child;
  }; // A recursive AST parser


  var searchNodes = function searchNodes(babylonParent, parent) {
    // Look through the node's children
    var child;

    if (!babylonParent.body || !Array.isArray(babylonParent.body)) {
      return;
    }

    babylonParent.body.forEach(function (element) {
      var _element$argument;

      child = undefined; // Pull out the node
      // const element = babylonParent.body[node];

      var _getNameForNode = getNameForNode(element),
          _getNameForNode2 = _slicedToArray(_getNameForNode, 2),
          name = _getNameForNode2[0],
          lastProperty = _getNameForNode2[1];

      if (isAnDescribe(name)) {
        child = addNode('describe', parent, element, lastProperty);
      } else if (isAnIt(name)) {
        child = addNode('it', parent, element, lastProperty);
      } else if (isAnExpect(element)) {
        child = addNode('expect', parent, element);
      } else if (element && element.type === 'VariableDeclaration') {
        element.declarations.filter(function (declaration) {
          return declaration.init && isFunctionDeclaration(declaration.init.type);
        }).forEach(function (declaration) {
          return searchNodes(declaration.init.body, parent);
        });
      } else if (element && element.type === 'ExpressionStatement' && element.expression && element.expression.type === 'AssignmentExpression' && element.expression.right && isFunctionDeclaration(element.expression.right.type)) {
        searchNodes(element.expression.right.body, parent);
      } else if (element.type === 'ReturnStatement' && (_element$argument = element.argument) !== null && _element$argument !== void 0 && _element$argument.arguments) {
        element.argument.arguments.filter(function (argument) {
          return isFunctionDeclaration(argument.type);
        }).forEach(function (argument) {
          return searchNodes(argument.body, parent);
        });
      }

      if (isFunctionCall(element)) {
        element.expression.arguments.filter(function (argument) {
          return isFunctionDeclaration(argument.type);
        }).forEach(function (argument) {
          return searchNodes(argument.body, child || parent);
        });
      }
    });
  };

  var program = ast.program;
  searchNodes(program, parseResult.root);
  return parseResult;
};

exports.parse = parse;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9wYXJzZXJzL2JhYmVsX3BhcnNlci5qcyJdLCJuYW1lcyI6WyJfZ2V0QVNUZm9yIiwiZmlsZSIsImRhdGEiLCJvcHRpb25zIiwiX2RhdGEiLCJ0b1N0cmluZyIsImNvbmZpZyIsInNvdXJjZVR5cGUiLCJwYXJzZXIiLCJwYXJzZSIsImdldEFTVGZvciIsImJGaWxlIiwicGFyc2VSZXN1bHQiLCJQYXJzZVJlc3VsdCIsImFzdCIsImRlZXBHZXQiLCJub2RlIiwidHlwZXMiLCJyZWR1Y2UiLCJyb290Rm9yVHlwZSIsInR5cGUiLCJ1cGRhdGVOYW1lSW5mbyIsIm5CbG9jayIsImJOb2RlIiwibGFzdFByb3BlcnR5IiwiYXJnIiwiZXhwcmVzc2lvbiIsImFyZ3VtZW50cyIsIm5hbWUiLCJ2YWx1ZSIsInN1YnN0cmluZyIsInN0YXJ0IiwiZW5kIiwibmFtZVR5cGUiLCJuYW1lUmFuZ2UiLCJQYXJzZWRSYW5nZSIsImxvYyIsImxpbmUiLCJjb2x1bW4iLCJ1cGRhdGVOb2RlIiwiYmFieWxvbk5vZGUiLCJhZGROb2RlIiwiTmFtZWRCbG9jayIsImlzRnVuY3Rpb25DYWxsIiwiaXNGdW5jdGlvbkRlY2xhcmF0aW9uIiwibm9kZVR5cGUiLCJnZXROYW1lRm9yTm9kZSIsImNhbGxlZSIsInJvb3RDYWxsZWUiLCJwcm9wZXJ0eSIsImlzQW5JdCIsImlzQW5EZXNjcmliZSIsImlzQW5FeHBlY3QiLCJlbGVtZW50IiwidW5kZWZpbmVkIiwib2JqZWN0IiwicGFyZW50IiwiY2hpbGQiLCJhZGRDaGlsZCIsImNvbnNvbGUiLCJ3YXJuIiwiSlNPTiIsInN0cmluZ2lmeSIsInNlYXJjaE5vZGVzIiwiYmFieWxvblBhcmVudCIsImJvZHkiLCJBcnJheSIsImlzQXJyYXkiLCJmb3JFYWNoIiwiZGVjbGFyYXRpb25zIiwiZmlsdGVyIiwiZGVjbGFyYXRpb24iLCJpbml0IiwicmlnaHQiLCJhcmd1bWVudCIsInByb2dyYW0iLCJyb290Il0sIm1hcHBpbmdzIjoiOzs7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SSxRQUFEO0FBQUEsaUJBQWM5QixxQkFBcUIsQ0FBQzhCLFFBQVEsQ0FBQ3RELElBQVYsQ0FBbkM7QUFBQSxTQURWLEVBRUdnRCxPQUZILENBRVcsVUFBQ00sUUFBRDtBQUFBLGlCQUFjWCxXQUFXLENBQUNXLFFBQVEsQ0FBQ1QsSUFBVixFQUFnQlIsS0FBSyxJQUFJRCxNQUF6QixDQUF6QjtBQUFBLFNBRlg7QUFHRDtBQUNGLEtBcENEO0FBcUNELEdBN0NEOztBQStDQSxNQUFPbUIsT0FBUCxHQUFrQjdELEdBQWxCLENBQU82RCxPQUFQO0FBQ0FaLEVBQUFBLFdBQVcsQ0FBQ1ksT0FBRCxFQUFVL0QsV0FBVyxDQUFDZ0UsSUFBdEIsQ0FBWDtBQUVBLFNBQU9oRSxXQUFQO0FBQ0QsQ0F6S00iLCJzb3VyY2VzQ29udGVudCI6WyIvKiBlc2xpbnQtZGlzYWJsZSBuby11bmRlcnNjb3JlLWRhbmdsZSAqL1xuLyogZXNsaW50LWRpc2FibGUgbm8tcGFyYW0tcmVhc3NpZ24gKi9cbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE0LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQGZsb3dcbiAqL1xuXG5pbXBvcnQge3JlYWRGaWxlU3luY30gZnJvbSAnZnMnO1xuaW1wb3J0IHtGaWxlIGFzIEJhYmVsRmlsZSwgTm9kZSBhcyBCYWJlbE5vZGV9IGZyb20gJ0BiYWJlbC90eXBlcyc7XG5pbXBvcnQgKiBhcyBwYXJzZXIgZnJvbSAnQGJhYmVsL3BhcnNlcic7XG5pbXBvcnQgdHlwZSB7UGFyc2VkTm9kZVR5cGV9IGZyb20gJy4vcGFyc2VyX25vZGVzJztcbmltcG9ydCB7TmFtZWRCbG9jaywgUGFyc2VkUmFuZ2UsIFBhcnNlUmVzdWx0LCBQYXJzZWROb2RlfSBmcm9tICcuL3BhcnNlcl9ub2Rlcyc7XG5pbXBvcnQge3BhcnNlT3B0aW9uc30gZnJvbSAnLi9oZWxwZXInO1xuXG5jb25zdCBfZ2V0QVNUZm9yID0gKGZpbGU6IHN0cmluZywgZGF0YTogP3N0cmluZywgb3B0aW9uczogP3BhcnNlci5QYXJzZXJPcHRpb25zKTogW0JhYmVsRmlsZSwgc3RyaW5nXSA9PiB7XG4gIGNvbnN0IF9kYXRhID0gZGF0YSB8fCByZWFkRmlsZVN5bmMoZmlsZSkudG9TdHJpbmcoKTtcbiAgY29uc3QgY29uZmlnID0gey4uLm9wdGlvbnMsIHNvdXJjZVR5cGU6ICdtb2R1bGUnfTtcbiAgcmV0dXJuIFtwYXJzZXIucGFyc2UoX2RhdGEsIGNvbmZpZyksIF9kYXRhXTtcbn07XG5cbmV4cG9ydCBjb25zdCBnZXRBU1Rmb3IgPSAoZmlsZTogc3RyaW5nLCBkYXRhOiA/c3RyaW5nKTogQmFiZWxGaWxlID0+IHtcbiAgY29uc3QgW2JGaWxlXSA9IF9nZXRBU1Rmb3IoZmlsZSwgZGF0YSwgcGFyc2VPcHRpb25zKGZpbGUpKTtcbiAgcmV0dXJuIGJGaWxlO1xufTtcblxuZXhwb3J0IGNvbnN0IHBhcnNlID0gKGZpbGU6IHN0cmluZywgZGF0YTogP3N0cmluZywgb3B0aW9uczogP3BhcnNlci5QYXJzZXJPcHRpb25zKTogUGFyc2VSZXN1bHQgPT4ge1xuICBjb25zdCBwYXJzZVJlc3VsdCA9IG5ldyBQYXJzZVJlc3VsdChmaWxlKTtcbiAgY29uc3QgW2FzdCwgX2RhdGFdID0gX2dldEFTVGZvcihmaWxlLCBkYXRhLCBvcHRpb25zKTtcblxuICBjb25zdCBkZWVwR2V0ID0gKG5vZGUsIC4uLnR5cGVzOiBzdHJpbmdbXSkgPT5cbiAgICB0eXBlcy5yZWR1Y2U8QmFiZWxOb2RlPigocm9vdEZvclR5cGUsIHR5cGUpID0+IHtcbiAgICAgIHdoaWxlIChyb290Rm9yVHlwZVt0eXBlXSkge1xuICAgICAgICByb290Rm9yVHlwZSA9IHJvb3RGb3JUeXBlW3R5cGVdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJvb3RGb3JUeXBlO1xuICAgIH0sIG5vZGUpO1xuXG4gIGNvbnN0IHVwZGF0ZU5hbWVJbmZvID0gKG5CbG9jazogTmFtZWRCbG9jaywgYk5vZGU6IEJhYmVsTm9kZSwgbGFzdFByb3BlcnR5Pzogc3RyaW5nKSA9PiB7XG4gICAgY29uc3QgYXJnID0gYk5vZGUuZXhwcmVzc2lvbi5hcmd1bWVudHNbMF07XG4gICAgbGV0IG5hbWUgPSBhcmcudmFsdWU7XG5cbiAgICBpZiAoIW5hbWUpIHtcbiAgICAgIHN3aXRjaCAoYXJnLnR5cGUpIHtcbiAgICAgICAgY2FzZSAnVGVtcGxhdGVMaXRlcmFsJzpcbiAgICAgICAgICBuYW1lID0gX2RhdGEuc3Vic3RyaW5nKGFyZy5zdGFydCArIDEsIGFyZy5lbmQgLSAxKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBuYW1lID0gX2RhdGEuc3Vic3RyaW5nKGFyZy5zdGFydCwgYXJnLmVuZCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbkJsb2NrLm5hbWUgPSBuYW1lO1xuICAgIG5CbG9jay5uYW1lVHlwZSA9IGFyZy50eXBlO1xuICAgIG5CbG9jay5sYXN0UHJvcGVydHkgPSBsYXN0UHJvcGVydHk7XG4gICAgbkJsb2NrLm5hbWVSYW5nZSA9IG5ldyBQYXJzZWRSYW5nZShcbiAgICAgIGFyZy5sb2Muc3RhcnQubGluZSxcbiAgICAgIGFyZy5sb2Muc3RhcnQuY29sdW1uICsgMixcbiAgICAgIGFyZy5sb2MuZW5kLmxpbmUsXG4gICAgICBhcmcubG9jLmVuZC5jb2x1bW4gLSAxXG4gICAgKTtcbiAgfTtcblxuICBjb25zdCB1cGRhdGVOb2RlID0gKG5vZGU6IFBhcnNlZE5vZGUsIGJhYnlsb25Ob2RlOiBCYWJlbE5vZGUsIGxhc3RQcm9wZXJ0eT86IHN0cmluZykgPT4ge1xuICAgIG5vZGUuc3RhcnQgPSBiYWJ5bG9uTm9kZS5sb2Muc3RhcnQ7XG4gICAgbm9kZS5lbmQgPSBiYWJ5bG9uTm9kZS5sb2MuZW5kO1xuICAgIG5vZGUuc3RhcnQuY29sdW1uICs9IDE7XG5cbiAgICBwYXJzZVJlc3VsdC5hZGROb2RlKG5vZGUpO1xuICAgIGlmIChub2RlIGluc3RhbmNlb2YgTmFtZWRCbG9jaykge1xuICAgICAgdXBkYXRlTmFtZUluZm8obm9kZSwgYmFieWxvbk5vZGUsIGxhc3RQcm9wZXJ0eSk7XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IGlzRnVuY3Rpb25DYWxsID0gKG5vZGUpID0+XG4gICAgbm9kZSAmJiBub2RlLnR5cGUgPT09ICdFeHByZXNzaW9uU3RhdGVtZW50JyAmJiBub2RlLmV4cHJlc3Npb24gJiYgbm9kZS5leHByZXNzaW9uLnR5cGUgPT09ICdDYWxsRXhwcmVzc2lvbic7XG5cbiAgY29uc3QgaXNGdW5jdGlvbkRlY2xhcmF0aW9uID0gKG5vZGVUeXBlOiBzdHJpbmcpID0+XG4gICAgbm9kZVR5cGUgPT09ICdBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvbicgfHwgbm9kZVR5cGUgPT09ICdGdW5jdGlvbkV4cHJlc3Npb24nO1xuXG4gIC8vIFB1bGwgb3V0IHRoZSBuYW1lIG9mIGEgQ2FsbEV4cHJlc3Npb24gKGRlc2NyaWJlL2l0KSBhbmQgdGhlIGxhc3QgcHJvcGVydHkgKGVhY2gsIHNraXAgZXRjKVxuICBjb25zdCBnZXROYW1lRm9yTm9kZSA9IChub2RlKSA9PiB7XG4gICAgaWYgKGlzRnVuY3Rpb25DYWxsKG5vZGUpICYmIG5vZGUuZXhwcmVzc2lvbi5jYWxsZWUpIHtcbiAgICAgIC8vIEdldCByb290IGNhbGxlZSBpbiBjYXNlIGl0J3MgYSBjaGFpbiBvZiBoaWdoZXItb3JkZXIgZnVuY3Rpb25zIChlLmcuIC5lYWNoKHRhYmxlKShuYW1lLCBmbikpXG4gICAgICBjb25zdCByb290Q2FsbGVlID0gZGVlcEdldChub2RlLmV4cHJlc3Npb24sICdjYWxsZWUnKTtcbiAgICAgIGNvbnN0IHByb3BlcnR5ID0gcm9vdENhbGxlZS5wcm9wZXJ0eT8ubmFtZSB8fCBkZWVwR2V0KHJvb3RDYWxsZWUsICd0YWcnKS5wcm9wZXJ0eT8ubmFtZTtcbiAgICAgIGNvbnN0IG5hbWUgPVxuICAgICAgICByb290Q2FsbGVlLm5hbWUgfHxcbiAgICAgICAgLy8gaGFuZGxlIGNhc2VzIHdoZXJlIGl0J3MgYSBtZW1iZXIgZXhwcmVzc2lvbiAoZS5nIC5vbmx5IG9yIC5jb25jdXJyZW50Lm9ubHkpXG4gICAgICAgIGRlZXBHZXQocm9vdENhbGxlZSwgJ29iamVjdCcpLm5hbWUgfHxcbiAgICAgICAgLy8gaGFuZGxlIGNhc2VzIHdoZXJlIGl0J3MgcGFydCBvZiBhIHRhZyAoZS5nLiAuZWFjaGB0YWJsZWApXG4gICAgICAgIGRlZXBHZXQocm9vdENhbGxlZSwgJ3RhZycsICdvYmplY3QnKS5uYW1lO1xuXG4gICAgICByZXR1cm4gW25hbWUsIHByb3BlcnR5XTtcbiAgICB9XG4gICAgcmV0dXJuIFtdO1xuICB9O1xuXG4gIC8vIFdoZW4gZ2l2ZW4gYSBub2RlIGluIHRoZSBBU1QsIGRvZXMgdGhpcyByZXByZXNlbnRcbiAgLy8gdGhlIHN0YXJ0IG9mIGFuIGl0L3Rlc3QgYmxvY2s/XG4gIGNvbnN0IGlzQW5JdCA9IChuYW1lPzogc3RyaW5nKSA9PiB7XG4gICAgcmV0dXJuIG5hbWUgPT09ICdpdCcgfHwgbmFtZSA9PT0gJ2ZpdCcgfHwgbmFtZSA9PT0gJ3Rlc3QnO1xuICB9O1xuXG4gIGNvbnN0IGlzQW5EZXNjcmliZSA9IChuYW1lPzogc3RyaW5nKSA9PiB7XG4gICAgcmV0dXJuIG5hbWUgPT09ICdkZXNjcmliZSc7XG4gIH07XG5cbiAgLy8gV2hlbiBnaXZlbiBhIG5vZGUgaW4gdGhlIEFTVCwgZG9lcyB0aGlzIHJlcHJlc2VudFxuICAvLyB0aGUgc3RhcnQgb2YgYW4gZXhwZWN0IGV4cHJlc3Npb24/XG4gIGNvbnN0IGlzQW5FeHBlY3QgPSAobm9kZSkgPT4ge1xuICAgIGlmICghaXNGdW5jdGlvbkNhbGwobm9kZSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgbGV0IG5hbWUgPSAnJztcbiAgICBsZXQgZWxlbWVudCA9IG5vZGUgJiYgbm9kZS5leHByZXNzaW9uID8gbm9kZS5leHByZXNzaW9uLmNhbGxlZSA6IHVuZGVmaW5lZDtcbiAgICB3aGlsZSAoIW5hbWUgJiYgZWxlbWVudCkge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZWZlci1kZXN0cnVjdHVyaW5nXG4gICAgICBuYW1lID0gZWxlbWVudC5uYW1lO1xuICAgICAgLy8gQmVjYXVzZSBleHBlY3QgbWF5IGhhdmUgYWNjZXNzb3JzIHRhY2tlZCBvbiAoLnRvLmJlKSBvciBub3RoaW5nXG4gICAgICAvLyAoZXhwZWN0KCkpIHdlIGhhdmUgdG8gY2hlY2sgbXVsdGlwbGUgbGV2ZWxzIGZvciB0aGUgbmFtZVxuICAgICAgZWxlbWVudCA9IGVsZW1lbnQub2JqZWN0IHx8IGVsZW1lbnQuY2FsbGVlO1xuICAgIH1cbiAgICByZXR1cm4gbmFtZSA9PT0gJ2V4cGVjdCc7XG4gIH07XG5cbiAgY29uc3QgYWRkTm9kZSA9IChcbiAgICB0eXBlOiBQYXJzZWROb2RlVHlwZSxcbiAgICBwYXJlbnQ6IFBhcnNlZE5vZGUsXG4gICAgYmFieWxvbk5vZGU6IEJhYmVsTm9kZSxcbiAgICBsYXN0UHJvcGVydHk/OiBzdHJpbmdcbiAgKTogUGFyc2VkTm9kZSA9PiB7XG4gICAgY29uc3QgY2hpbGQgPSBwYXJlbnQuYWRkQ2hpbGQodHlwZSk7XG4gICAgdXBkYXRlTm9kZShjaGlsZCwgYmFieWxvbk5vZGUsIGxhc3RQcm9wZXJ0eSk7XG5cbiAgICBpZiAoY2hpbGQgaW5zdGFuY2VvZiBOYW1lZEJsb2NrICYmIGNoaWxkLm5hbWUgPT0gbnVsbCkge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgIGNvbnNvbGUud2FybihgYmxvY2sgaXMgbWlzc2luZyBuYW1lOiAke0pTT04uc3RyaW5naWZ5KGJhYnlsb25Ob2RlKX1gKTtcbiAgICB9XG4gICAgcmV0dXJuIGNoaWxkO1xuICB9O1xuXG4gIC8vIEEgcmVjdXJzaXZlIEFTVCBwYXJzZXJcbiAgY29uc3Qgc2VhcmNoTm9kZXMgPSAoYmFieWxvblBhcmVudDogQmFiZWxOb2RlLCBwYXJlbnQ6IFBhcnNlZE5vZGUpID0+IHtcbiAgICAvLyBMb29rIHRocm91Z2ggdGhlIG5vZGUncyBjaGlsZHJlblxuICAgIGxldCBjaGlsZDogP1BhcnNlZE5vZGU7XG5cbiAgICBpZiAoIWJhYnlsb25QYXJlbnQuYm9keSB8fCAhQXJyYXkuaXNBcnJheShiYWJ5bG9uUGFyZW50LmJvZHkpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgYmFieWxvblBhcmVudC5ib2R5LmZvckVhY2goKGVsZW1lbnQpID0+IHtcbiAgICAgIGNoaWxkID0gdW5kZWZpbmVkO1xuICAgICAgLy8gUHVsbCBvdXQgdGhlIG5vZGVcbiAgICAgIC8vIGNvbnN0IGVsZW1lbnQgPSBiYWJ5bG9uUGFyZW50LmJvZHlbbm9kZV07XG5cbiAgICAgIGNvbnN0IFtuYW1lLCBsYXN0UHJvcGVydHldID0gZ2V0TmFtZUZvck5vZGUoZWxlbWVudCk7XG4gICAgICBpZiAoaXNBbkRlc2NyaWJlKG5hbWUpKSB7XG4gICAgICAgIGNoaWxkID0gYWRkTm9kZSgnZGVzY3JpYmUnLCBwYXJlbnQsIGVsZW1lbnQsIGxhc3RQcm9wZXJ0eSk7XG4gICAgICB9IGVsc2UgaWYgKGlzQW5JdChuYW1lKSkge1xuICAgICAgICBjaGlsZCA9IGFkZE5vZGUoJ2l0JywgcGFyZW50LCBlbGVtZW50LCBsYXN0UHJvcGVydHkpO1xuICAgICAgfSBlbHNlIGlmIChpc0FuRXhwZWN0KGVsZW1lbnQpKSB7XG4gICAgICAgIGNoaWxkID0gYWRkTm9kZSgnZXhwZWN0JywgcGFyZW50LCBlbGVtZW50KTtcbiAgICAgIH0gZWxzZSBpZiAoZWxlbWVudCAmJiBlbGVtZW50LnR5cGUgPT09ICdWYXJpYWJsZURlY2xhcmF0aW9uJykge1xuICAgICAgICBlbGVtZW50LmRlY2xhcmF0aW9uc1xuICAgICAgICAgIC5maWx0ZXIoKGRlY2xhcmF0aW9uKSA9PiBkZWNsYXJhdGlvbi5pbml0ICYmIGlzRnVuY3Rpb25EZWNsYXJhdGlvbihkZWNsYXJhdGlvbi5pbml0LnR5cGUpKVxuICAgICAgICAgIC5mb3JFYWNoKChkZWNsYXJhdGlvbikgPT4gc2VhcmNoTm9kZXMoZGVjbGFyYXRpb24uaW5pdC5ib2R5LCBwYXJlbnQpKTtcbiAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgIGVsZW1lbnQgJiZcbiAgICAgICAgZWxlbWVudC50eXBlID09PSAnRXhwcmVzc2lvblN0YXRlbWVudCcgJiZcbiAgICAgICAgZWxlbWVudC5leHByZXNzaW9uICYmXG4gICAgICAgIGVsZW1lbnQuZXhwcmVzc2lvbi50eXBlID09PSAnQXNzaWdubWVudEV4cHJlc3Npb24nICYmXG4gICAgICAgIGVsZW1lbnQuZXhwcmVzc2lvbi5yaWdodCAmJlxuICAgICAgICBpc0Z1bmN0aW9uRGVjbGFyYXRpb24oZWxlbWVudC5leHByZXNzaW9uLnJpZ2h0LnR5cGUpXG4gICAgICApIHtcbiAgICAgICAgc2VhcmNoTm9kZXMoZWxlbWVudC5leHByZXNzaW9uLnJpZ2h0LmJvZHksIHBhcmVudCk7XG4gICAgICB9IGVsc2UgaWYgKGVsZW1lbnQudHlwZSA9PT0gJ1JldHVyblN0YXRlbWVudCcgJiYgZWxlbWVudC5hcmd1bWVudD8uYXJndW1lbnRzKSB7XG4gICAgICAgIGVsZW1lbnQuYXJndW1lbnQuYXJndW1lbnRzXG4gICAgICAgICAgLmZpbHRlcigoYXJndW1lbnQpID0+IGlzRnVuY3Rpb25EZWNsYXJhdGlvbihhcmd1bWVudC50eXBlKSlcbiAgICAgICAgICAuZm9yRWFjaCgoYXJndW1lbnQpID0+IHNlYXJjaE5vZGVzKGFyZ3VtZW50LmJvZHksIHBhcmVudCkpO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNGdW5jdGlvbkNhbGwoZWxlbWVudCkpIHtcbiAgICAgICAgZWxlbWVudC5leHByZXNzaW9uLmFyZ3VtZW50c1xuICAgICAgICAgIC5maWx0ZXIoKGFyZ3VtZW50KSA9PiBpc0Z1bmN0aW9uRGVjbGFyYXRpb24oYXJndW1lbnQudHlwZSkpXG4gICAgICAgICAgLmZvckVhY2goKGFyZ3VtZW50KSA9PiBzZWFyY2hOb2Rlcyhhcmd1bWVudC5ib2R5LCBjaGlsZCB8fCBwYXJlbnQpKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICBjb25zdCB7cHJvZ3JhbX0gPSBhc3Q7XG4gIHNlYXJjaE5vZGVzKHByb2dyYW0sIHBhcnNlUmVzdWx0LnJvb3QpO1xuXG4gIHJldHVybiBwYXJzZVJlc3VsdDtcbn07XG4iXX0=