"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createProjectWorkspace = exports["default"] = void 0;

require("core-js/modules/es.regexp.exec.js");

require("core-js/modules/es.string.replace.js");

require("core-js/modules/es.object.define-property.js");

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

/**
 * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */

/**
 * Represents the project that the extension is running on and it's state
 */
var ProjectWorkspace = /*#__PURE__*/function () {
  function ProjectWorkspace(rootPath, jestCommandLine, pathToConfig, localJestMajorVersion, outputFileSuffix, collectCoverage, debug, nodeEnv, shell) {
    _classCallCheck(this, ProjectWorkspace);

    this.rootPath = rootPath;
    this.jestCommandLine = jestCommandLine;
    this.pathToConfig = pathToConfig;
    this.localJestMajorVersion = localJestMajorVersion;
    this.outputFileSuffix = outputFileSuffix ? outputFileSuffix.replace(/[^a-z0-9]/gi, '_').toLowerCase() : undefined;
    this.collectCoverage = collectCoverage;
    this.debug = debug;
    this.nodeEnv = nodeEnv;
    this.shell = shell;
  }

  _createClass(ProjectWorkspace, [{
    key: "pathToJest",
    get:
    /**
     * The path to the root of the project's workspace
     *
     * @type {string}
     */

    /**
     * The command to execute Jest on the command line, this is normally a file path like
     * `node_modules/.bin/jest` but you should not make the assumption that it is always a direct
     * file path, as in a create-react app it would look like `npm test --`.
     *
     * This means when launching a process, you will need to split on the first
     * space, and then move any other args into the args of the process.
     *
     * @type {string}
     */

    /**
     * @deprecated please use `jestCommandLine` instead.
     *
     * @type {string?}
     */
    function get() {
      // eslint-disable-next-line no-console
      console.warn('Use of ProjectWorkspace.pathToJest is deprecated.  Please use jestCommandLine instead.');
      return this.jestCommandLine;
    },
    set: function set(commandLine) {
      // eslint-disable-next-line no-console
      console.warn('Use of ProjectWorkspace.pathToJest is deprecated.  Please use jestCommandLine instead.');
      this.jestCommandLine = commandLine;
    }
    /**
     * Path to a local Jest config file.
     *
     * @type {string}
     */

  }]);

  return ProjectWorkspace;
}();
/**
 * A factory to create a ProjectWorkspace instance from a ProjectWorkspaceConfig object.
 */


exports["default"] = ProjectWorkspace;

var createProjectWorkspace = function createProjectWorkspace(config) {
  // Note for pathToConfig we are forcing the TS compiler to accept undefined for ProjectWorkspace.pathToConfig.
  // This property should be allowed to be optional, since Jest will work fine if no config file is provided.  It
  // will just use defaults.
  return new ProjectWorkspace(config.rootPath, config.jestCommandLine, config.pathToConfig, config.localJestMajorVersion, config.outputFileSuffix, config.collectCoverage, config.debug, config.nodeEnv, config.shell);
};

exports.createProjectWorkspace = createProjectWorkspace;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9wcm9qZWN0X3dvcmtzcGFjZS50cyJdLCJuYW1lcyI6WyJQcm9qZWN0V29ya3NwYWNlIiwicm9vdFBhdGgiLCJqZXN0Q29tbWFuZExpbmUiLCJwYXRoVG9Db25maWciLCJsb2NhbEplc3RNYWpvclZlcnNpb24iLCJvdXRwdXRGaWxlU3VmZml4IiwiY29sbGVjdENvdmVyYWdlIiwiZGVidWciLCJub2RlRW52Iiwic2hlbGwiLCJyZXBsYWNlIiwidG9Mb3dlckNhc2UiLCJ1bmRlZmluZWQiLCJjb25zb2xlIiwid2FybiIsImNvbW1hbmRMaW5lIiwiY3JlYXRlUHJvamVjdFdvcmtzcGFjZSIsImNvbmZpZyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQWNBO0FBQ0E7QUFDQTtJQUNxQkEsZ0I7QUFxRm5CLDRCQUNFQyxRQURGLEVBRUVDLGVBRkYsRUFHRUMsWUFIRixFQUlFQyxxQkFKRixFQUtFQyxnQkFMRixFQU1FQyxlQU5GLEVBT0VDLEtBUEYsRUFRRUMsT0FSRixFQVNFQyxLQVRGLEVBVUU7QUFBQTs7QUFDQSxTQUFLUixRQUFMLEdBQWdCQSxRQUFoQjtBQUNBLFNBQUtDLGVBQUwsR0FBdUJBLGVBQXZCO0FBQ0EsU0FBS0MsWUFBTCxHQUFvQkEsWUFBcEI7QUFDQSxTQUFLQyxxQkFBTCxHQUE2QkEscUJBQTdCO0FBQ0EsU0FBS0MsZ0JBQUwsR0FBd0JBLGdCQUFnQixHQUFHQSxnQkFBZ0IsQ0FBQ0ssT0FBakIsQ0FBeUIsYUFBekIsRUFBd0MsR0FBeEMsRUFBNkNDLFdBQTdDLEVBQUgsR0FBZ0VDLFNBQXhHO0FBQ0EsU0FBS04sZUFBTCxHQUF1QkEsZUFBdkI7QUFDQSxTQUFLQyxLQUFMLEdBQWFBLEtBQWI7QUFDQSxTQUFLQyxPQUFMLEdBQWVBLE9BQWY7QUFDQSxTQUFLQyxLQUFMLEdBQWFBLEtBQWI7QUFDRDs7Ozs7QUF4R0Q7QUFDRjtBQUNBO0FBQ0E7QUFDQTs7QUFHRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFHRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0UsbUJBQXlCO0FBQ3ZCO0FBQ0FJLE1BQUFBLE9BQU8sQ0FBQ0MsSUFBUixDQUFhLHdGQUFiO0FBQ0EsYUFBTyxLQUFLWixlQUFaO0FBQ0QsSztTQUVELGFBQWVhLFdBQWYsRUFBb0M7QUFDbEM7QUFDQUYsTUFBQUEsT0FBTyxDQUFDQyxJQUFSLENBQWEsd0ZBQWI7QUFDQSxXQUFLWixlQUFMLEdBQXVCYSxXQUF2QjtBQUNEO0FBRUQ7QUFDRjtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FBbUVBO0FBQ0E7QUFDQTs7Ozs7QUFDTyxJQUFNQyxzQkFBc0IsR0FBRyxTQUF6QkEsc0JBQXlCLENBQUNDLE1BQUQsRUFBc0Q7QUFDMUY7QUFDQTtBQUNBO0FBQ0EsU0FBTyxJQUFJakIsZ0JBQUosQ0FDTGlCLE1BQU0sQ0FBQ2hCLFFBREYsRUFFTGdCLE1BQU0sQ0FBQ2YsZUFGRixFQUdMZSxNQUFNLENBQUNkLFlBSEYsRUFJTGMsTUFBTSxDQUFDYixxQkFKRixFQUtMYSxNQUFNLENBQUNaLGdCQUxGLEVBTUxZLE1BQU0sQ0FBQ1gsZUFORixFQU9MVyxNQUFNLENBQUNWLEtBUEYsRUFRTFUsTUFBTSxDQUFDVCxPQVJGLEVBU0xTLE1BQU0sQ0FBQ1IsS0FURixDQUFQO0FBV0QsQ0FmTSIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE0LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbmV4cG9ydCBpbnRlcmZhY2UgUHJvamVjdFdvcmtzcGFjZUNvbmZpZyB7XG4gIGplc3RDb21tYW5kTGluZTogc3RyaW5nO1xuICBwYXRoVG9Db25maWc/OiBzdHJpbmc7XG4gIHJvb3RQYXRoOiBzdHJpbmc7XG4gIGxvY2FsSmVzdE1ham9yVmVyc2lvbjogbnVtYmVyO1xuICBvdXRwdXRGaWxlU3VmZml4Pzogc3RyaW5nO1xuICBjb2xsZWN0Q292ZXJhZ2U/OiBib29sZWFuO1xuICBkZWJ1Zz86IGJvb2xlYW47XG4gIG5vZGVFbnY/OiB7W2tleTogc3RyaW5nXTogc3RyaW5nIHwgdW5kZWZpbmVkfTtcbiAgc2hlbGw/OiBzdHJpbmc7XG59XG5cbi8qKlxuICogUmVwcmVzZW50cyB0aGUgcHJvamVjdCB0aGF0IHRoZSBleHRlbnNpb24gaXMgcnVubmluZyBvbiBhbmQgaXQncyBzdGF0ZVxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQcm9qZWN0V29ya3NwYWNlIHtcbiAgLyoqXG4gICAqIFRoZSBwYXRoIHRvIHRoZSByb290IG9mIHRoZSBwcm9qZWN0J3Mgd29ya3NwYWNlXG4gICAqXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICByb290UGF0aDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgY29tbWFuZCB0byBleGVjdXRlIEplc3Qgb24gdGhlIGNvbW1hbmQgbGluZSwgdGhpcyBpcyBub3JtYWxseSBhIGZpbGUgcGF0aCBsaWtlXG4gICAqIGBub2RlX21vZHVsZXMvLmJpbi9qZXN0YCBidXQgeW91IHNob3VsZCBub3QgbWFrZSB0aGUgYXNzdW1wdGlvbiB0aGF0IGl0IGlzIGFsd2F5cyBhIGRpcmVjdFxuICAgKiBmaWxlIHBhdGgsIGFzIGluIGEgY3JlYXRlLXJlYWN0IGFwcCBpdCB3b3VsZCBsb29rIGxpa2UgYG5wbSB0ZXN0IC0tYC5cbiAgICpcbiAgICogVGhpcyBtZWFucyB3aGVuIGxhdW5jaGluZyBhIHByb2Nlc3MsIHlvdSB3aWxsIG5lZWQgdG8gc3BsaXQgb24gdGhlIGZpcnN0XG4gICAqIHNwYWNlLCBhbmQgdGhlbiBtb3ZlIGFueSBvdGhlciBhcmdzIGludG8gdGhlIGFyZ3Mgb2YgdGhlIHByb2Nlc3MuXG4gICAqXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBqZXN0Q29tbWFuZExpbmU6IHN0cmluZztcblxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgcGxlYXNlIHVzZSBgamVzdENvbW1hbmRMaW5lYCBpbnN0ZWFkLlxuICAgKlxuICAgKiBAdHlwZSB7c3RyaW5nP31cbiAgICovXG4gIGdldCBwYXRoVG9KZXN0KCk6IHN0cmluZyB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICBjb25zb2xlLndhcm4oJ1VzZSBvZiBQcm9qZWN0V29ya3NwYWNlLnBhdGhUb0plc3QgaXMgZGVwcmVjYXRlZC4gIFBsZWFzZSB1c2UgamVzdENvbW1hbmRMaW5lIGluc3RlYWQuJyk7XG4gICAgcmV0dXJuIHRoaXMuamVzdENvbW1hbmRMaW5lO1xuICB9XG5cbiAgc2V0IHBhdGhUb0plc3QoY29tbWFuZExpbmU6IHN0cmluZykge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgY29uc29sZS53YXJuKCdVc2Ugb2YgUHJvamVjdFdvcmtzcGFjZS5wYXRoVG9KZXN0IGlzIGRlcHJlY2F0ZWQuICBQbGVhc2UgdXNlIGplc3RDb21tYW5kTGluZSBpbnN0ZWFkLicpO1xuICAgIHRoaXMuamVzdENvbW1hbmRMaW5lID0gY29tbWFuZExpbmU7XG4gIH1cblxuICAvKipcbiAgICogUGF0aCB0byBhIGxvY2FsIEplc3QgY29uZmlnIGZpbGUuXG4gICAqXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBwYXRoVG9Db25maWc6IHN0cmluZztcblxuICAvKipcbiAgICogbG9jYWwgSmVzdCBtYWpvciByZWxlYXNlIHZlcnNpb24sIGFzIHRoZSBydW5uZXIgY291bGQgcnVuIGFnYWluc3RcbiAgICogYW55IHZlcnNpb24gb2YgSmVzdC5cbiAgICpcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIGxvY2FsSmVzdE1ham9yVmVyc2lvbjogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRlc3QgY292ZXJhZ2Ugc2hvdWxkIGJlIChhdXRvbWF0aWNhbGx5KSBjb2xsZWN0ZWQuXG4gICAqXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKi9cbiAgY29sbGVjdENvdmVyYWdlPzogYm9vbGVhbjtcblxuICAvKipcbiAgICogaWYgdG8gb3V0cHV0IG1vcmUgaW5mb3JtYXRpb24gZm9yIGRlYnVnZ2luZyBwdXJwb3NlLiBEZWZhdWx0IGlzIGZhbHNlLlxuICAgKlxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICovXG4gIGRlYnVnPzogYm9vbGVhbjtcblxuICAvKipcbiAgICogc3VmZml4IHN0cmluZyB1c2VkIGFzIHBhcnQgb2YgdGhlIG91dHB1dCBmaWxlIHBhdGgsIHRoaXMgaXMgdG8gc3VwcG9ydCBjb25jdXJyZW50IFJ1bm5lcnMuXG4gICAqXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqIEBtZW1iZXJvZiBQcm9qZWN0V29ya3NwYWNlXG4gICAqL1xuICBvdXRwdXRGaWxlU3VmZml4Pzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBvcHRpb25hbCBhZGRpdGlvbmFsIG5vZGUgZW52IHZhcmlhYmxlc1xuICAgKi9cbiAgbm9kZUVudj86IHtba2V5OiBzdHJpbmddOiBzdHJpbmcgfCB1bmRlZmluZWR9O1xuXG4gIC8qKlxuICAgKiBvcHRpb25hbCBjdXN0b20gc2hlbGwgZm9yIG5vZGUgY2hpbGRfcHJvY2VzcyBzcGF3bigpIGNhbGwuIERlZmF1bHQgaXMgJy9iaW4vc2gnIG9uIFVuaXgsIGFuZCBwcm9jZXNzLmVudi5Db21TcGVjIG9uIFdpbmRvd3MuXG4gICAqIHNlZSBodHRwczovL25vZGVqcy5vcmcvYXBpL2NoaWxkX3Byb2Nlc3MuaHRtbCNjaGlsZF9wcm9jZXNzX2NoaWxkX3Byb2Nlc3Nfc3Bhd25fY29tbWFuZF9hcmdzX29wdGlvbnNcbiAgICovXG4gIHNoZWxsPzogc3RyaW5nO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHJvb3RQYXRoOiBzdHJpbmcsXG4gICAgamVzdENvbW1hbmRMaW5lOiBzdHJpbmcsXG4gICAgcGF0aFRvQ29uZmlnOiBzdHJpbmcsXG4gICAgbG9jYWxKZXN0TWFqb3JWZXJzaW9uOiBudW1iZXIsXG4gICAgb3V0cHV0RmlsZVN1ZmZpeD86IHN0cmluZyxcbiAgICBjb2xsZWN0Q292ZXJhZ2U/OiBib29sZWFuLFxuICAgIGRlYnVnPzogYm9vbGVhbixcbiAgICBub2RlRW52Pzoge1trZXk6IHN0cmluZ106IHN0cmluZyB8IHVuZGVmaW5lZH0sXG4gICAgc2hlbGw/OiBzdHJpbmdcbiAgKSB7XG4gICAgdGhpcy5yb290UGF0aCA9IHJvb3RQYXRoO1xuICAgIHRoaXMuamVzdENvbW1hbmRMaW5lID0gamVzdENvbW1hbmRMaW5lO1xuICAgIHRoaXMucGF0aFRvQ29uZmlnID0gcGF0aFRvQ29uZmlnO1xuICAgIHRoaXMubG9jYWxKZXN0TWFqb3JWZXJzaW9uID0gbG9jYWxKZXN0TWFqb3JWZXJzaW9uO1xuICAgIHRoaXMub3V0cHV0RmlsZVN1ZmZpeCA9IG91dHB1dEZpbGVTdWZmaXggPyBvdXRwdXRGaWxlU3VmZml4LnJlcGxhY2UoL1teYS16MC05XS9naSwgJ18nKS50b0xvd2VyQ2FzZSgpIDogdW5kZWZpbmVkO1xuICAgIHRoaXMuY29sbGVjdENvdmVyYWdlID0gY29sbGVjdENvdmVyYWdlO1xuICAgIHRoaXMuZGVidWcgPSBkZWJ1ZztcbiAgICB0aGlzLm5vZGVFbnYgPSBub2RlRW52O1xuICAgIHRoaXMuc2hlbGwgPSBzaGVsbDtcbiAgfVxufVxuXG4vKipcbiAqIEEgZmFjdG9yeSB0byBjcmVhdGUgYSBQcm9qZWN0V29ya3NwYWNlIGluc3RhbmNlIGZyb20gYSBQcm9qZWN0V29ya3NwYWNlQ29uZmlnIG9iamVjdC5cbiAqL1xuZXhwb3J0IGNvbnN0IGNyZWF0ZVByb2plY3RXb3Jrc3BhY2UgPSAoY29uZmlnOiBQcm9qZWN0V29ya3NwYWNlQ29uZmlnKTogUHJvamVjdFdvcmtzcGFjZSA9PiB7XG4gIC8vIE5vdGUgZm9yIHBhdGhUb0NvbmZpZyB3ZSBhcmUgZm9yY2luZyB0aGUgVFMgY29tcGlsZXIgdG8gYWNjZXB0IHVuZGVmaW5lZCBmb3IgUHJvamVjdFdvcmtzcGFjZS5wYXRoVG9Db25maWcuXG4gIC8vIFRoaXMgcHJvcGVydHkgc2hvdWxkIGJlIGFsbG93ZWQgdG8gYmUgb3B0aW9uYWwsIHNpbmNlIEplc3Qgd2lsbCB3b3JrIGZpbmUgaWYgbm8gY29uZmlnIGZpbGUgaXMgcHJvdmlkZWQuICBJdFxuICAvLyB3aWxsIGp1c3QgdXNlIGRlZmF1bHRzLlxuICByZXR1cm4gbmV3IFByb2plY3RXb3Jrc3BhY2UoXG4gICAgY29uZmlnLnJvb3RQYXRoLFxuICAgIGNvbmZpZy5qZXN0Q29tbWFuZExpbmUsXG4gICAgY29uZmlnLnBhdGhUb0NvbmZpZyBhcyB1bmtub3duIGFzIHN0cmluZyxcbiAgICBjb25maWcubG9jYWxKZXN0TWFqb3JWZXJzaW9uLFxuICAgIGNvbmZpZy5vdXRwdXRGaWxlU3VmZml4LFxuICAgIGNvbmZpZy5jb2xsZWN0Q292ZXJhZ2UsXG4gICAgY29uZmlnLmRlYnVnLFxuICAgIGNvbmZpZy5ub2RlRW52LFxuICAgIGNvbmZpZy5zaGVsbFxuICApO1xufTtcbiJdfQ==