"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

require("core-js/modules/es.reflect.construct.js");

require("core-js/modules/es.object.create.js");

require("core-js/modules/es.object.define-property.js");

require("core-js/modules/es.array.is-array.js");

require("core-js/modules/es.symbol.js");

require("core-js/modules/es.symbol.description.js");

require("core-js/modules/es.symbol.iterator.js");

require("core-js/modules/es.array.iterator.js");

require("core-js/modules/es.string.iterator.js");

require("core-js/modules/web.dom-collections.iterator.js");

require("core-js/modules/es.array.from.js");

require("core-js/modules/es.array.slice.js");

require("core-js/modules/es.function.name.js");

require("core-js/modules/es.weak-map.js");

require("core-js/modules/es.object.get-own-property-descriptor.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

require("core-js/modules/es.regexp.exec.js");

require("core-js/modules/es.string.replace.js");

require("core-js/modules/es.array.for-each.js");

require("core-js/modules/web.dom-collections.for-each.js");

require("core-js/modules/es.date.to-string.js");

require("core-js/modules/es.object.to-string.js");

require("core-js/modules/es.regexp.to-string.js");

require("core-js/modules/es.array.concat.js");

require("core-js/modules/es.array.find.js");

require("core-js/modules/es.object.set-prototype-of.js");

require("core-js/modules/es.object.get-prototype-of.js");

var _child_process = require("child_process");

var _fs = require("fs");

var _os = require("os");

var path = _interopRequireWildcard(require("path"));

var _events = _interopRequireDefault(require("events"));

var _types = require("./types");

var _project_workspace = _interopRequireDefault(require("./project_workspace"));

var _Process = require("./Process");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

// This class represents the running process, and
// passes out events when it understands what data is being
// pass sent out of the process
var Runner = /*#__PURE__*/function (_EventEmitter) {
  _inherits(Runner, _EventEmitter);

  var _super = _createSuper(Runner);

  function Runner(workspace, options) {
    var _this;

    _classCallCheck(this, Runner);

    _this = _super.call(this);
    _this._createProcess = options && options.createProcess || _Process.createProcess;
    _this.options = options || {};
    _this.workspace = workspace;
    _this.outputPath = path.join((0, _os.tmpdir)(), "jest_runner_".concat(_this.workspace.outputFileSuffix || '', ".json"));
    _this.prevMessageTypes = [];
    _this._exited = false;
    return _this;
  }

  _createClass(Runner, [{
    key: "_getArgs",
    value: function _getArgs() {
      if (this.options.args && this.options.args.replace) {
        return this.options.args.args;
      } // Handle the arg change on v18


      var belowEighteen = this.workspace.localJestMajorVersion < 18;
      var outputArg = belowEighteen ? '--jsonOutputFile' : '--outputFile';
      var args = ['--testLocationInResults', '--json', '--useStderr', outputArg, this.outputPath];

      if (this.watchMode) {
        args.push(this.watchAll ? '--watchAll' : '--watch');
      }

      if (this.options.testNamePattern) {
        args.push('--testNamePattern', this.options.testNamePattern);
      }

      if (this.options.testFileNamePattern) {
        args.push(this.options.testFileNamePattern);
      }

      if (this.workspace.collectCoverage === true) {
        args.push('--coverage');
      }

      if (this.workspace.collectCoverage === false) {
        args.push('--no-coverage');
      }

      if (this.options.noColor === true) {
        args.push('--no-color');
      }

      if (this.options.reporters) {
        this.options.reporters.forEach(function (reporter) {
          args.push('--reporters', reporter);
        });
      }

      if (this.options.args) {
        args.push.apply(args, _toConsumableArray(this.options.args.args));
      }

      return args;
    }
  }, {
    key: "start",
    value: function start() {
      var _this2 = this;

      var watchMode = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
      var watchAll = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      if (this.debugprocess) {
        return;
      }

      this.watchMode = watchMode;
      this.watchAll = watchAll;

      var args = this._getArgs();

      this.debugprocess = this._createProcess(this.workspace, args);
      this.debugprocess.stdout.on('data', function (data) {
        _this2._parseOutput(data, false);
      });
      this.debugprocess.stderr.on('data', function (data) {
        // jest 23 could send test results message to stderr
        // see https://github.com/facebook/jest/pull/4858
        _this2._parseOutput(data, true);
      });
      this.debugprocess.on('exit', function (code, signal) {
        _this2._exited = true; // this is mainly for backward compatibility, should be deprecated soon

        _this2.emit('debuggerProcessExit');

        _this2.emit('processExit', code, signal);

        _this2.prevMessageTypes.length = 0;
      });
      this.debugprocess.on('error', function (error) {
        _this2.emit('terminalError', "Process failed: ".concat(error.message));

        _this2.prevMessageTypes.length = 0;
      });
      this.debugprocess.on('close', function (code, signal) {
        // this is mainly for backward compatibility, should be deprecated soon
        _this2.emit('debuggerProcessExit');

        _this2.emit('processClose', code, signal);

        _this2.prevMessageTypes.length = 0;
      });
    }
    /**
     * parse the stdin/out stream buffer for recognized messages.
     *
     * note: if these messages coming in in separate chucks, we might not be able to
     * resolve it properly. While there haven't been much evidence of such scenario,
     * it's worth to note that it could and we might need to buffer them in that case.
     * see https://github.com/jest-community/jest-editor-support/pull/9#pullrequestreview-231888752
     *
     * @param {Buffer} data
     * @param {boolean} isStdErr
     * @returns {MessageType}
     * @memberof Runner
     */

  }, {
    key: "_parseOutput",
    value: function _parseOutput(data, isStdErr) {
      var _this3 = this;

      var msgType = this.findMessageType(data);

      switch (msgType) {
        case _types.messageTypes.testResults:
          (0, _fs.readFile)(this.outputPath, 'utf8', function (err, _data) {
            if (err) {
              var message = "JSON report not found at ".concat(_this3.outputPath);

              _this3.emit('terminalError', message);
            } else {
              var noTestsFound = _this3.doResultsFollowNoTestsFoundMessage();

              _this3.emit('executableJSON', JSON.parse(_data), {
                noTestsFound: noTestsFound
              });
            }
          });
          this.prevMessageTypes.length = 0;
          break;

        case _types.messageTypes.watchUsage:
        case _types.messageTypes.noTests:
          this.prevMessageTypes.push(msgType);
          this.emit('executableStdErr', data, {
            type: msgType
          });
          break;

        default:
          // no special action needed, just report the output by its source
          if (isStdErr) {
            this.emit('executableStdErr', data, {
              type: msgType
            });
          } else {
            this.emit('executableOutput', data.toString().replace('[2J[H', ''));
          }

          this.prevMessageTypes.length = 0;
          break;
      }

      return msgType;
    }
  }, {
    key: "runJestWithUpdateForSnapshots",
    value: function runJestWithUpdateForSnapshots(completion, args) {
      var defaultArgs = ['--updateSnapshot'];

      var updateProcess = this._createProcess(this.workspace, [].concat(defaultArgs, _toConsumableArray(args || [])));

      updateProcess.on('close', function () {
        completion();
      });
    }
  }, {
    key: "closeProcess",
    value: function closeProcess() {
      if (!this.debugprocess || this._exited) {
        // eslint-disable-next-line no-console
        console.log("process has not started or already exited");
        return;
      }

      if (process.platform === 'win32') {
        // Windows doesn't exit the process when it should.
        (0, _child_process.spawn)('taskkill', ['/pid', "".concat(this.debugprocess.pid), '/T', '/F']);
      } else {
        try {
          // kill all process with the same PGID, i.e.
          // as a detached process, it is the same as the PID of the leader process.
          process.kill(-this.debugprocess.pid);
        } catch (e) {
          // if anything goes wrong, fallback to the old benavior
          // knowing this could leave orphan process...
          // eslint-disable-next-line no-console
          console.warn("failed to kill process group, this could leave some orphan process whose ppid=".concat(this.debugprocess.pid, ". error="), e);
          this.debugprocess.kill();
        }
      }

      delete this.debugprocess;
    } // eslint-disable-next-line class-methods-use-this

  }, {
    key: "findMessageType",
    value: function findMessageType(buf) {
      var noTestRegex = /No tests found related to files changed since ((last commit)|("[a-z0-9]+"))./;
      var watchUsageRegex = /^\s*Watch Usage\b/;
      var testResultsRegex = /Test results written to/;
      var checks = [{
        regex: testResultsRegex,
        messageType: _types.messageTypes.testResults
      }, {
        regex: noTestRegex,
        messageType: _types.messageTypes.noTests
      }, {
        regex: watchUsageRegex,
        messageType: _types.messageTypes.watchUsage
      }];
      var str = buf.toString('utf8');
      var match = checks.find(function (_ref) {
        var regex = _ref.regex;
        return regex.test(str);
      });
      return match ? match.messageType : _types.messageTypes.unknown;
    }
  }, {
    key: "doResultsFollowNoTestsFoundMessage",
    value: function doResultsFollowNoTestsFoundMessage() {
      if (this.prevMessageTypes.length === 1) {
        return this.prevMessageTypes[0] === _types.messageTypes.noTests;
      }

      if (this.prevMessageTypes.length === 2) {
        return this.prevMessageTypes[0] === _types.messageTypes.noTests && this.prevMessageTypes[1] === _types.messageTypes.watchUsage;
      }

      return false;
    }
  }]);

  return Runner;
}(_events["default"]);

exports["default"] = Runner;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9SdW5uZXIuanMiXSwibmFtZXMiOlsiUnVubmVyIiwid29ya3NwYWNlIiwib3B0aW9ucyIsIl9jcmVhdGVQcm9jZXNzIiwiY3JlYXRlUHJvY2VzcyIsIm91dHB1dFBhdGgiLCJwYXRoIiwiam9pbiIsIm91dHB1dEZpbGVTdWZmaXgiLCJwcmV2TWVzc2FnZVR5cGVzIiwiX2V4aXRlZCIsImFyZ3MiLCJyZXBsYWNlIiwiYmVsb3dFaWdodGVlbiIsImxvY2FsSmVzdE1ham9yVmVyc2lvbiIsIm91dHB1dEFyZyIsIndhdGNoTW9kZSIsInB1c2giLCJ3YXRjaEFsbCIsInRlc3ROYW1lUGF0dGVybiIsInRlc3RGaWxlTmFtZVBhdHRlcm4iLCJjb2xsZWN0Q292ZXJhZ2UiLCJub0NvbG9yIiwicmVwb3J0ZXJzIiwiZm9yRWFjaCIsInJlcG9ydGVyIiwiZGVidWdwcm9jZXNzIiwiX2dldEFyZ3MiLCJzdGRvdXQiLCJvbiIsImRhdGEiLCJfcGFyc2VPdXRwdXQiLCJzdGRlcnIiLCJjb2RlIiwic2lnbmFsIiwiZW1pdCIsImxlbmd0aCIsImVycm9yIiwibWVzc2FnZSIsImlzU3RkRXJyIiwibXNnVHlwZSIsImZpbmRNZXNzYWdlVHlwZSIsIm1lc3NhZ2VUeXBlcyIsInRlc3RSZXN1bHRzIiwiZXJyIiwiX2RhdGEiLCJub1Rlc3RzRm91bmQiLCJkb1Jlc3VsdHNGb2xsb3dOb1Rlc3RzRm91bmRNZXNzYWdlIiwiSlNPTiIsInBhcnNlIiwid2F0Y2hVc2FnZSIsIm5vVGVzdHMiLCJ0eXBlIiwidG9TdHJpbmciLCJjb21wbGV0aW9uIiwiZGVmYXVsdEFyZ3MiLCJ1cGRhdGVQcm9jZXNzIiwiY29uc29sZSIsImxvZyIsInByb2Nlc3MiLCJwbGF0Zm9ybSIsInBpZCIsImtpbGwiLCJlIiwid2FybiIsImJ1ZiIsIm5vVGVzdFJlZ2V4Iiwid2F0Y2hVc2FnZVJlZ2V4IiwidGVzdFJlc3VsdHNSZWdleCIsImNoZWNrcyIsInJlZ2V4IiwibWVzc2FnZVR5cGUiLCJzdHIiLCJtYXRjaCIsImZpbmQiLCJ0ZXN0IiwidW5rbm93biIsIkV2ZW50RW1pdHRlciJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQVNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUVBOztBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBRUE7QUFDQTtBQUNBO0lBQ3FCQSxNOzs7OztBQW1CbkIsa0JBQVlDLFNBQVosRUFBeUNDLE9BQXpDLEVBQTREO0FBQUE7O0FBQUE7O0FBQzFEO0FBRUEsVUFBS0MsY0FBTCxHQUF1QkQsT0FBTyxJQUFJQSxPQUFPLENBQUNFLGFBQXBCLElBQXNDQSxzQkFBNUQ7QUFDQSxVQUFLRixPQUFMLEdBQWVBLE9BQU8sSUFBSSxFQUExQjtBQUNBLFVBQUtELFNBQUwsR0FBaUJBLFNBQWpCO0FBQ0EsVUFBS0ksVUFBTCxHQUFrQkMsSUFBSSxDQUFDQyxJQUFMLENBQVUsaUJBQVYsd0JBQW1DLE1BQUtOLFNBQUwsQ0FBZU8sZ0JBQWYsSUFBbUMsRUFBdEUsV0FBbEI7QUFDQSxVQUFLQyxnQkFBTCxHQUF3QixFQUF4QjtBQUNBLFVBQUtDLE9BQUwsR0FBZSxLQUFmO0FBUjBEO0FBUzNEOzs7O1dBRUQsb0JBQXFCO0FBQ25CLFVBQUksS0FBS1IsT0FBTCxDQUFhUyxJQUFiLElBQXFCLEtBQUtULE9BQUwsQ0FBYVMsSUFBYixDQUFrQkMsT0FBM0MsRUFBb0Q7QUFDbEQsZUFBTyxLQUFLVixPQUFMLENBQWFTLElBQWIsQ0FBa0JBLElBQXpCO0FBQ0QsT0FIa0IsQ0FLbkI7OztBQUNBLFVBQU1FLGFBQWEsR0FBRyxLQUFLWixTQUFMLENBQWVhLHFCQUFmLEdBQXVDLEVBQTdEO0FBQ0EsVUFBTUMsU0FBUyxHQUFHRixhQUFhLEdBQUcsa0JBQUgsR0FBd0IsY0FBdkQ7QUFDQSxVQUFNRixJQUFJLEdBQUcsQ0FBQyx5QkFBRCxFQUE0QixRQUE1QixFQUFzQyxhQUF0QyxFQUFxREksU0FBckQsRUFBZ0UsS0FBS1YsVUFBckUsQ0FBYjs7QUFDQSxVQUFJLEtBQUtXLFNBQVQsRUFBb0I7QUFDbEJMLFFBQUFBLElBQUksQ0FBQ00sSUFBTCxDQUFVLEtBQUtDLFFBQUwsR0FBZ0IsWUFBaEIsR0FBK0IsU0FBekM7QUFDRDs7QUFDRCxVQUFJLEtBQUtoQixPQUFMLENBQWFpQixlQUFqQixFQUFrQztBQUNoQ1IsUUFBQUEsSUFBSSxDQUFDTSxJQUFMLENBQVUsbUJBQVYsRUFBK0IsS0FBS2YsT0FBTCxDQUFhaUIsZUFBNUM7QUFDRDs7QUFDRCxVQUFJLEtBQUtqQixPQUFMLENBQWFrQixtQkFBakIsRUFBc0M7QUFDcENULFFBQUFBLElBQUksQ0FBQ00sSUFBTCxDQUFVLEtBQUtmLE9BQUwsQ0FBYWtCLG1CQUF2QjtBQUNEOztBQUNELFVBQUksS0FBS25CLFNBQUwsQ0FBZW9CLGVBQWYsS0FBbUMsSUFBdkMsRUFBNkM7QUFDM0NWLFFBQUFBLElBQUksQ0FBQ00sSUFBTCxDQUFVLFlBQVY7QUFDRDs7QUFDRCxVQUFJLEtBQUtoQixTQUFMLENBQWVvQixlQUFmLEtBQW1DLEtBQXZDLEVBQThDO0FBQzVDVixRQUFBQSxJQUFJLENBQUNNLElBQUwsQ0FBVSxlQUFWO0FBQ0Q7O0FBQ0QsVUFBSSxLQUFLZixPQUFMLENBQWFvQixPQUFiLEtBQXlCLElBQTdCLEVBQW1DO0FBQ2pDWCxRQUFBQSxJQUFJLENBQUNNLElBQUwsQ0FBVSxZQUFWO0FBQ0Q7O0FBQ0QsVUFBSSxLQUFLZixPQUFMLENBQWFxQixTQUFqQixFQUE0QjtBQUMxQixhQUFLckIsT0FBTCxDQUFhcUIsU0FBYixDQUF1QkMsT0FBdkIsQ0FBK0IsVUFBQ0MsUUFBRCxFQUFjO0FBQzNDZCxVQUFBQSxJQUFJLENBQUNNLElBQUwsQ0FBVSxhQUFWLEVBQXlCUSxRQUF6QjtBQUNELFNBRkQ7QUFHRDs7QUFDRCxVQUFJLEtBQUt2QixPQUFMLENBQWFTLElBQWpCLEVBQXVCO0FBQ3JCQSxRQUFBQSxJQUFJLENBQUNNLElBQUwsT0FBQU4sSUFBSSxxQkFBUyxLQUFLVCxPQUFMLENBQWFTLElBQWIsQ0FBa0JBLElBQTNCLEVBQUo7QUFDRDs7QUFDRCxhQUFPQSxJQUFQO0FBQ0Q7OztXQUVELGlCQUE0RDtBQUFBOztBQUFBLFVBQXRESyxTQUFzRCx1RUFBakMsSUFBaUM7QUFBQSxVQUEzQkUsUUFBMkIsdUVBQVAsS0FBTzs7QUFDMUQsVUFBSSxLQUFLUSxZQUFULEVBQXVCO0FBQ3JCO0FBQ0Q7O0FBRUQsV0FBS1YsU0FBTCxHQUFpQkEsU0FBakI7QUFDQSxXQUFLRSxRQUFMLEdBQWdCQSxRQUFoQjs7QUFFQSxVQUFNUCxJQUFJLEdBQUcsS0FBS2dCLFFBQUwsRUFBYjs7QUFDQSxXQUFLRCxZQUFMLEdBQW9CLEtBQUt2QixjQUFMLENBQW9CLEtBQUtGLFNBQXpCLEVBQW9DVSxJQUFwQyxDQUFwQjtBQUNBLFdBQUtlLFlBQUwsQ0FBa0JFLE1BQWxCLENBQXlCQyxFQUF6QixDQUE0QixNQUE1QixFQUFvQyxVQUFDQyxJQUFELEVBQWtCO0FBQ3BELFFBQUEsTUFBSSxDQUFDQyxZQUFMLENBQWtCRCxJQUFsQixFQUF3QixLQUF4QjtBQUNELE9BRkQ7QUFJQSxXQUFLSixZQUFMLENBQWtCTSxNQUFsQixDQUF5QkgsRUFBekIsQ0FBNEIsTUFBNUIsRUFBb0MsVUFBQ0MsSUFBRCxFQUFrQjtBQUNwRDtBQUNBO0FBQ0EsUUFBQSxNQUFJLENBQUNDLFlBQUwsQ0FBa0JELElBQWxCLEVBQXdCLElBQXhCO0FBQ0QsT0FKRDtBQUtBLFdBQUtKLFlBQUwsQ0FBa0JHLEVBQWxCLENBQXFCLE1BQXJCLEVBQTZCLFVBQUNJLElBQUQsRUFBc0JDLE1BQXRCLEVBQWdEO0FBQzNFLFFBQUEsTUFBSSxDQUFDeEIsT0FBTCxHQUFlLElBQWYsQ0FEMkUsQ0FHM0U7O0FBQ0EsUUFBQSxNQUFJLENBQUN5QixJQUFMLENBQVUscUJBQVY7O0FBRUEsUUFBQSxNQUFJLENBQUNBLElBQUwsQ0FBVSxhQUFWLEVBQXlCRixJQUF6QixFQUErQkMsTUFBL0I7O0FBQ0EsUUFBQSxNQUFJLENBQUN6QixnQkFBTCxDQUFzQjJCLE1BQXRCLEdBQStCLENBQS9CO0FBQ0QsT0FSRDtBQVVBLFdBQUtWLFlBQUwsQ0FBa0JHLEVBQWxCLENBQXFCLE9BQXJCLEVBQThCLFVBQUNRLEtBQUQsRUFBa0I7QUFDOUMsUUFBQSxNQUFJLENBQUNGLElBQUwsQ0FBVSxlQUFWLDRCQUE4Q0UsS0FBSyxDQUFDQyxPQUFwRDs7QUFDQSxRQUFBLE1BQUksQ0FBQzdCLGdCQUFMLENBQXNCMkIsTUFBdEIsR0FBK0IsQ0FBL0I7QUFDRCxPQUhEO0FBS0EsV0FBS1YsWUFBTCxDQUFrQkcsRUFBbEIsQ0FBcUIsT0FBckIsRUFBOEIsVUFBQ0ksSUFBRCxFQUFzQkMsTUFBdEIsRUFBZ0Q7QUFDNUU7QUFDQSxRQUFBLE1BQUksQ0FBQ0MsSUFBTCxDQUFVLHFCQUFWOztBQUVBLFFBQUEsTUFBSSxDQUFDQSxJQUFMLENBQVUsY0FBVixFQUEwQkYsSUFBMUIsRUFBZ0NDLE1BQWhDOztBQUNBLFFBQUEsTUFBSSxDQUFDekIsZ0JBQUwsQ0FBc0IyQixNQUF0QixHQUErQixDQUEvQjtBQUNELE9BTkQ7QUFPRDtBQUVEO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O1dBQ0Usc0JBQWFOLElBQWIsRUFBMkJTLFFBQTNCLEVBQTJEO0FBQUE7O0FBQ3pELFVBQU1DLE9BQU8sR0FBRyxLQUFLQyxlQUFMLENBQXFCWCxJQUFyQixDQUFoQjs7QUFDQSxjQUFRVSxPQUFSO0FBQ0UsYUFBS0Usb0JBQWFDLFdBQWxCO0FBQ0UsNEJBQVMsS0FBS3RDLFVBQWQsRUFBMEIsTUFBMUIsRUFBa0MsVUFBQ3VDLEdBQUQsRUFBTUMsS0FBTixFQUFnQjtBQUNoRCxnQkFBSUQsR0FBSixFQUFTO0FBQ1Asa0JBQU1OLE9BQU8sc0NBQStCLE1BQUksQ0FBQ2pDLFVBQXBDLENBQWI7O0FBQ0EsY0FBQSxNQUFJLENBQUM4QixJQUFMLENBQVUsZUFBVixFQUEyQkcsT0FBM0I7QUFDRCxhQUhELE1BR087QUFDTCxrQkFBTVEsWUFBWSxHQUFHLE1BQUksQ0FBQ0Msa0NBQUwsRUFBckI7O0FBQ0EsY0FBQSxNQUFJLENBQUNaLElBQUwsQ0FBVSxnQkFBVixFQUE0QmEsSUFBSSxDQUFDQyxLQUFMLENBQVdKLEtBQVgsQ0FBNUIsRUFBK0M7QUFDN0NDLGdCQUFBQSxZQUFZLEVBQVpBO0FBRDZDLGVBQS9DO0FBR0Q7QUFDRixXQVZEO0FBV0EsZUFBS3JDLGdCQUFMLENBQXNCMkIsTUFBdEIsR0FBK0IsQ0FBL0I7QUFDQTs7QUFDRixhQUFLTSxvQkFBYVEsVUFBbEI7QUFDQSxhQUFLUixvQkFBYVMsT0FBbEI7QUFDRSxlQUFLMUMsZ0JBQUwsQ0FBc0JRLElBQXRCLENBQTJCdUIsT0FBM0I7QUFDQSxlQUFLTCxJQUFMLENBQVUsa0JBQVYsRUFBOEJMLElBQTlCLEVBQW9DO0FBQ2xDc0IsWUFBQUEsSUFBSSxFQUFFWjtBQUQ0QixXQUFwQztBQUdBOztBQUNGO0FBQ0U7QUFDQSxjQUFJRCxRQUFKLEVBQWM7QUFDWixpQkFBS0osSUFBTCxDQUFVLGtCQUFWLEVBQThCTCxJQUE5QixFQUFvQztBQUNsQ3NCLGNBQUFBLElBQUksRUFBRVo7QUFENEIsYUFBcEM7QUFHRCxXQUpELE1BSU87QUFDTCxpQkFBS0wsSUFBTCxDQUFVLGtCQUFWLEVBQThCTCxJQUFJLENBQUN1QixRQUFMLEdBQWdCekMsT0FBaEIsQ0FBd0IsU0FBeEIsRUFBbUMsRUFBbkMsQ0FBOUI7QUFDRDs7QUFDRCxlQUFLSCxnQkFBTCxDQUFzQjJCLE1BQXRCLEdBQStCLENBQS9CO0FBQ0E7QUFoQ0o7O0FBbUNBLGFBQU9JLE9BQVA7QUFDRDs7O1dBRUQsdUNBQThCYyxVQUE5QixFQUFzRDNDLElBQXRELEVBQXVFO0FBQ3JFLFVBQU00QyxXQUFXLEdBQUcsQ0FBQyxrQkFBRCxDQUFwQjs7QUFFQSxVQUFNQyxhQUFhLEdBQUcsS0FBS3JELGNBQUwsQ0FBb0IsS0FBS0YsU0FBekIsWUFBd0NzRCxXQUF4QyxxQkFBeUQ1QyxJQUFJLElBQUksRUFBakUsR0FBdEI7O0FBQ0E2QyxNQUFBQSxhQUFhLENBQUMzQixFQUFkLENBQWlCLE9BQWpCLEVBQTBCLFlBQU07QUFDOUJ5QixRQUFBQSxVQUFVO0FBQ1gsT0FGRDtBQUdEOzs7V0FFRCx3QkFBZTtBQUNiLFVBQUksQ0FBQyxLQUFLNUIsWUFBTixJQUFzQixLQUFLaEIsT0FBL0IsRUFBd0M7QUFDdEM7QUFDQStDLFFBQUFBLE9BQU8sQ0FBQ0MsR0FBUjtBQUNBO0FBQ0Q7O0FBQ0QsVUFBSUMsT0FBTyxDQUFDQyxRQUFSLEtBQXFCLE9BQXpCLEVBQWtDO0FBQ2hDO0FBQ0Esa0NBQU0sVUFBTixFQUFrQixDQUFDLE1BQUQsWUFBWSxLQUFLbEMsWUFBTCxDQUFrQm1DLEdBQTlCLEdBQXFDLElBQXJDLEVBQTJDLElBQTNDLENBQWxCO0FBQ0QsT0FIRCxNQUdPO0FBQ0wsWUFBSTtBQUNGO0FBQ0E7QUFDQUYsVUFBQUEsT0FBTyxDQUFDRyxJQUFSLENBQWEsQ0FBQyxLQUFLcEMsWUFBTCxDQUFrQm1DLEdBQWhDO0FBQ0QsU0FKRCxDQUlFLE9BQU9FLENBQVAsRUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBTixVQUFBQSxPQUFPLENBQUNPLElBQVIseUZBQ21GLEtBQUt0QyxZQUFMLENBQWtCbUMsR0FEckcsZUFFRUUsQ0FGRjtBQUlBLGVBQUtyQyxZQUFMLENBQWtCb0MsSUFBbEI7QUFDRDtBQUNGOztBQUNELGFBQU8sS0FBS3BDLFlBQVo7QUFDRCxLLENBRUQ7Ozs7V0FDQSx5QkFBZ0J1QyxHQUFoQixFQUEwQztBQUN4QyxVQUFNQyxXQUFXLEdBQUcsOEVBQXBCO0FBQ0EsVUFBTUMsZUFBZSxHQUFHLG1CQUF4QjtBQUNBLFVBQU1DLGdCQUFnQixHQUFHLHlCQUF6QjtBQUVBLFVBQU1DLE1BQU0sR0FBRyxDQUNiO0FBQUNDLFFBQUFBLEtBQUssRUFBRUYsZ0JBQVI7QUFBMEJHLFFBQUFBLFdBQVcsRUFBRTdCLG9CQUFhQztBQUFwRCxPQURhLEVBRWI7QUFBQzJCLFFBQUFBLEtBQUssRUFBRUosV0FBUjtBQUFxQkssUUFBQUEsV0FBVyxFQUFFN0Isb0JBQWFTO0FBQS9DLE9BRmEsRUFHYjtBQUFDbUIsUUFBQUEsS0FBSyxFQUFFSCxlQUFSO0FBQXlCSSxRQUFBQSxXQUFXLEVBQUU3QixvQkFBYVE7QUFBbkQsT0FIYSxDQUFmO0FBTUEsVUFBTXNCLEdBQUcsR0FBR1AsR0FBRyxDQUFDWixRQUFKLENBQWEsTUFBYixDQUFaO0FBQ0EsVUFBTW9CLEtBQUssR0FBR0osTUFBTSxDQUFDSyxJQUFQLENBQVk7QUFBQSxZQUFFSixLQUFGLFFBQUVBLEtBQUY7QUFBQSxlQUFhQSxLQUFLLENBQUNLLElBQU4sQ0FBV0gsR0FBWCxDQUFiO0FBQUEsT0FBWixDQUFkO0FBQ0EsYUFBT0MsS0FBSyxHQUFHQSxLQUFLLENBQUNGLFdBQVQsR0FBdUI3QixvQkFBYWtDLE9BQWhEO0FBQ0Q7OztXQUVELDhDQUFxQztBQUNuQyxVQUFJLEtBQUtuRSxnQkFBTCxDQUFzQjJCLE1BQXRCLEtBQWlDLENBQXJDLEVBQXdDO0FBQ3RDLGVBQU8sS0FBSzNCLGdCQUFMLENBQXNCLENBQXRCLE1BQTZCaUMsb0JBQWFTLE9BQWpEO0FBQ0Q7O0FBRUQsVUFBSSxLQUFLMUMsZ0JBQUwsQ0FBc0IyQixNQUF0QixLQUFpQyxDQUFyQyxFQUF3QztBQUN0QyxlQUFPLEtBQUszQixnQkFBTCxDQUFzQixDQUF0QixNQUE2QmlDLG9CQUFhUyxPQUExQyxJQUFxRCxLQUFLMUMsZ0JBQUwsQ0FBc0IsQ0FBdEIsTUFBNkJpQyxvQkFBYVEsVUFBdEc7QUFDRDs7QUFFRCxhQUFPLEtBQVA7QUFDRDs7OztFQXBPaUMyQixrQiIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE0LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQGZsb3dcbiAqL1xuXG5pbXBvcnQge0NoaWxkUHJvY2Vzcywgc3Bhd259IGZyb20gJ2NoaWxkX3Byb2Nlc3MnO1xuaW1wb3J0IHtyZWFkRmlsZX0gZnJvbSAnZnMnO1xuaW1wb3J0IHt0bXBkaXJ9IGZyb20gJ29zJztcbmltcG9ydCAqIGFzIHBhdGggZnJvbSAncGF0aCc7XG5pbXBvcnQgRXZlbnRFbWl0dGVyIGZyb20gJ2V2ZW50cyc7XG5pbXBvcnQge21lc3NhZ2VUeXBlc30gZnJvbSAnLi90eXBlcyc7XG5pbXBvcnQgdHlwZSB7T3B0aW9ucywgTWVzc2FnZVR5cGV9IGZyb20gJy4vdHlwZXMnO1xuaW1wb3J0IFByb2plY3RXb3Jrc3BhY2UgZnJvbSAnLi9wcm9qZWN0X3dvcmtzcGFjZSc7XG5pbXBvcnQge2NyZWF0ZVByb2Nlc3N9IGZyb20gJy4vUHJvY2Vzcyc7XG5cbi8vIFRoaXMgY2xhc3MgcmVwcmVzZW50cyB0aGUgcnVubmluZyBwcm9jZXNzLCBhbmRcbi8vIHBhc3NlcyBvdXQgZXZlbnRzIHdoZW4gaXQgdW5kZXJzdGFuZHMgd2hhdCBkYXRhIGlzIGJlaW5nXG4vLyBwYXNzIHNlbnQgb3V0IG9mIHRoZSBwcm9jZXNzXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSdW5uZXIgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICBkZWJ1Z3Byb2Nlc3M6IENoaWxkUHJvY2VzcztcblxuICBvdXRwdXRQYXRoOiBzdHJpbmc7XG5cbiAgd29ya3NwYWNlOiBQcm9qZWN0V29ya3NwYWNlO1xuXG4gIF9jcmVhdGVQcm9jZXNzOiAod29ya3NwYWNlOiBQcm9qZWN0V29ya3NwYWNlLCBhcmdzOiBBcnJheTxzdHJpbmc+KSA9PiBDaGlsZFByb2Nlc3M7XG5cbiAgd2F0Y2hNb2RlOiBib29sZWFuO1xuXG4gIHdhdGNoQWxsOiBib29sZWFuO1xuXG4gIG9wdGlvbnM6IE9wdGlvbnM7XG5cbiAgcHJldk1lc3NhZ2VUeXBlczogTWVzc2FnZVR5cGVbXTtcblxuICBfZXhpdGVkOiBib29sZWFuO1xuXG4gIGNvbnN0cnVjdG9yKHdvcmtzcGFjZTogUHJvamVjdFdvcmtzcGFjZSwgb3B0aW9ucz86IE9wdGlvbnMpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgdGhpcy5fY3JlYXRlUHJvY2VzcyA9IChvcHRpb25zICYmIG9wdGlvbnMuY3JlYXRlUHJvY2VzcykgfHwgY3JlYXRlUHJvY2VzcztcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIHRoaXMud29ya3NwYWNlID0gd29ya3NwYWNlO1xuICAgIHRoaXMub3V0cHV0UGF0aCA9IHBhdGguam9pbih0bXBkaXIoKSwgYGplc3RfcnVubmVyXyR7dGhpcy53b3Jrc3BhY2Uub3V0cHV0RmlsZVN1ZmZpeCB8fCAnJ30uanNvbmApO1xuICAgIHRoaXMucHJldk1lc3NhZ2VUeXBlcyA9IFtdO1xuICAgIHRoaXMuX2V4aXRlZCA9IGZhbHNlO1xuICB9XG5cbiAgX2dldEFyZ3MoKTogc3RyaW5nW10ge1xuICAgIGlmICh0aGlzLm9wdGlvbnMuYXJncyAmJiB0aGlzLm9wdGlvbnMuYXJncy5yZXBsYWNlKSB7XG4gICAgICByZXR1cm4gdGhpcy5vcHRpb25zLmFyZ3MuYXJncztcbiAgICB9XG5cbiAgICAvLyBIYW5kbGUgdGhlIGFyZyBjaGFuZ2Ugb24gdjE4XG4gICAgY29uc3QgYmVsb3dFaWdodGVlbiA9IHRoaXMud29ya3NwYWNlLmxvY2FsSmVzdE1ham9yVmVyc2lvbiA8IDE4O1xuICAgIGNvbnN0IG91dHB1dEFyZyA9IGJlbG93RWlnaHRlZW4gPyAnLS1qc29uT3V0cHV0RmlsZScgOiAnLS1vdXRwdXRGaWxlJztcbiAgICBjb25zdCBhcmdzID0gWyctLXRlc3RMb2NhdGlvbkluUmVzdWx0cycsICctLWpzb24nLCAnLS11c2VTdGRlcnInLCBvdXRwdXRBcmcsIHRoaXMub3V0cHV0UGF0aF07XG4gICAgaWYgKHRoaXMud2F0Y2hNb2RlKSB7XG4gICAgICBhcmdzLnB1c2godGhpcy53YXRjaEFsbCA/ICctLXdhdGNoQWxsJyA6ICctLXdhdGNoJyk7XG4gICAgfVxuICAgIGlmICh0aGlzLm9wdGlvbnMudGVzdE5hbWVQYXR0ZXJuKSB7XG4gICAgICBhcmdzLnB1c2goJy0tdGVzdE5hbWVQYXR0ZXJuJywgdGhpcy5vcHRpb25zLnRlc3ROYW1lUGF0dGVybik7XG4gICAgfVxuICAgIGlmICh0aGlzLm9wdGlvbnMudGVzdEZpbGVOYW1lUGF0dGVybikge1xuICAgICAgYXJncy5wdXNoKHRoaXMub3B0aW9ucy50ZXN0RmlsZU5hbWVQYXR0ZXJuKTtcbiAgICB9XG4gICAgaWYgKHRoaXMud29ya3NwYWNlLmNvbGxlY3RDb3ZlcmFnZSA9PT0gdHJ1ZSkge1xuICAgICAgYXJncy5wdXNoKCctLWNvdmVyYWdlJyk7XG4gICAgfVxuICAgIGlmICh0aGlzLndvcmtzcGFjZS5jb2xsZWN0Q292ZXJhZ2UgPT09IGZhbHNlKSB7XG4gICAgICBhcmdzLnB1c2goJy0tbm8tY292ZXJhZ2UnKTtcbiAgICB9XG4gICAgaWYgKHRoaXMub3B0aW9ucy5ub0NvbG9yID09PSB0cnVlKSB7XG4gICAgICBhcmdzLnB1c2goJy0tbm8tY29sb3InKTtcbiAgICB9XG4gICAgaWYgKHRoaXMub3B0aW9ucy5yZXBvcnRlcnMpIHtcbiAgICAgIHRoaXMub3B0aW9ucy5yZXBvcnRlcnMuZm9yRWFjaCgocmVwb3J0ZXIpID0+IHtcbiAgICAgICAgYXJncy5wdXNoKCctLXJlcG9ydGVycycsIHJlcG9ydGVyKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAodGhpcy5vcHRpb25zLmFyZ3MpIHtcbiAgICAgIGFyZ3MucHVzaCguLi50aGlzLm9wdGlvbnMuYXJncy5hcmdzKTtcbiAgICB9XG4gICAgcmV0dXJuIGFyZ3M7XG4gIH1cblxuICBzdGFydCh3YXRjaE1vZGU6IGJvb2xlYW4gPSB0cnVlLCB3YXRjaEFsbDogYm9vbGVhbiA9IGZhbHNlKSB7XG4gICAgaWYgKHRoaXMuZGVidWdwcm9jZXNzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy53YXRjaE1vZGUgPSB3YXRjaE1vZGU7XG4gICAgdGhpcy53YXRjaEFsbCA9IHdhdGNoQWxsO1xuXG4gICAgY29uc3QgYXJncyA9IHRoaXMuX2dldEFyZ3MoKTtcbiAgICB0aGlzLmRlYnVncHJvY2VzcyA9IHRoaXMuX2NyZWF0ZVByb2Nlc3ModGhpcy53b3Jrc3BhY2UsIGFyZ3MpO1xuICAgIHRoaXMuZGVidWdwcm9jZXNzLnN0ZG91dC5vbignZGF0YScsIChkYXRhOiBCdWZmZXIpID0+IHtcbiAgICAgIHRoaXMuX3BhcnNlT3V0cHV0KGRhdGEsIGZhbHNlKTtcbiAgICB9KTtcblxuICAgIHRoaXMuZGVidWdwcm9jZXNzLnN0ZGVyci5vbignZGF0YScsIChkYXRhOiBCdWZmZXIpID0+IHtcbiAgICAgIC8vIGplc3QgMjMgY291bGQgc2VuZCB0ZXN0IHJlc3VsdHMgbWVzc2FnZSB0byBzdGRlcnJcbiAgICAgIC8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svamVzdC9wdWxsLzQ4NThcbiAgICAgIHRoaXMuX3BhcnNlT3V0cHV0KGRhdGEsIHRydWUpO1xuICAgIH0pO1xuICAgIHRoaXMuZGVidWdwcm9jZXNzLm9uKCdleGl0JywgKGNvZGU6IG51bWJlciB8IG51bGwsIHNpZ25hbDogc3RyaW5nIHwgbnVsbCkgPT4ge1xuICAgICAgdGhpcy5fZXhpdGVkID0gdHJ1ZTtcblxuICAgICAgLy8gdGhpcyBpcyBtYWlubHkgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIHNob3VsZCBiZSBkZXByZWNhdGVkIHNvb25cbiAgICAgIHRoaXMuZW1pdCgnZGVidWdnZXJQcm9jZXNzRXhpdCcpO1xuXG4gICAgICB0aGlzLmVtaXQoJ3Byb2Nlc3NFeGl0JywgY29kZSwgc2lnbmFsKTtcbiAgICAgIHRoaXMucHJldk1lc3NhZ2VUeXBlcy5sZW5ndGggPSAwO1xuICAgIH0pO1xuXG4gICAgdGhpcy5kZWJ1Z3Byb2Nlc3Mub24oJ2Vycm9yJywgKGVycm9yOiBFcnJvcikgPT4ge1xuICAgICAgdGhpcy5lbWl0KCd0ZXJtaW5hbEVycm9yJywgYFByb2Nlc3MgZmFpbGVkOiAke2Vycm9yLm1lc3NhZ2V9YCk7XG4gICAgICB0aGlzLnByZXZNZXNzYWdlVHlwZXMubGVuZ3RoID0gMDtcbiAgICB9KTtcblxuICAgIHRoaXMuZGVidWdwcm9jZXNzLm9uKCdjbG9zZScsIChjb2RlOiBudW1iZXIgfCBudWxsLCBzaWduYWw6IHN0cmluZyB8IG51bGwpID0+IHtcbiAgICAgIC8vIHRoaXMgaXMgbWFpbmx5IGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCBzaG91bGQgYmUgZGVwcmVjYXRlZCBzb29uXG4gICAgICB0aGlzLmVtaXQoJ2RlYnVnZ2VyUHJvY2Vzc0V4aXQnKTtcblxuICAgICAgdGhpcy5lbWl0KCdwcm9jZXNzQ2xvc2UnLCBjb2RlLCBzaWduYWwpO1xuICAgICAgdGhpcy5wcmV2TWVzc2FnZVR5cGVzLmxlbmd0aCA9IDA7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogcGFyc2UgdGhlIHN0ZGluL291dCBzdHJlYW0gYnVmZmVyIGZvciByZWNvZ25pemVkIG1lc3NhZ2VzLlxuICAgKlxuICAgKiBub3RlOiBpZiB0aGVzZSBtZXNzYWdlcyBjb21pbmcgaW4gaW4gc2VwYXJhdGUgY2h1Y2tzLCB3ZSBtaWdodCBub3QgYmUgYWJsZSB0b1xuICAgKiByZXNvbHZlIGl0IHByb3Blcmx5LiBXaGlsZSB0aGVyZSBoYXZlbid0IGJlZW4gbXVjaCBldmlkZW5jZSBvZiBzdWNoIHNjZW5hcmlvLFxuICAgKiBpdCdzIHdvcnRoIHRvIG5vdGUgdGhhdCBpdCBjb3VsZCBhbmQgd2UgbWlnaHQgbmVlZCB0byBidWZmZXIgdGhlbSBpbiB0aGF0IGNhc2UuXG4gICAqIHNlZSBodHRwczovL2dpdGh1Yi5jb20vamVzdC1jb21tdW5pdHkvamVzdC1lZGl0b3Itc3VwcG9ydC9wdWxsLzkjcHVsbHJlcXVlc3RyZXZpZXctMjMxODg4NzUyXG4gICAqXG4gICAqIEBwYXJhbSB7QnVmZmVyfSBkYXRhXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNTdGRFcnJcbiAgICogQHJldHVybnMge01lc3NhZ2VUeXBlfVxuICAgKiBAbWVtYmVyb2YgUnVubmVyXG4gICAqL1xuICBfcGFyc2VPdXRwdXQoZGF0YTogQnVmZmVyLCBpc1N0ZEVycjogYm9vbGVhbik6IE1lc3NhZ2VUeXBlIHtcbiAgICBjb25zdCBtc2dUeXBlID0gdGhpcy5maW5kTWVzc2FnZVR5cGUoZGF0YSk7XG4gICAgc3dpdGNoIChtc2dUeXBlKSB7XG4gICAgICBjYXNlIG1lc3NhZ2VUeXBlcy50ZXN0UmVzdWx0czpcbiAgICAgICAgcmVhZEZpbGUodGhpcy5vdXRwdXRQYXRoLCAndXRmOCcsIChlcnIsIF9kYXRhKSA9PiB7XG4gICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgY29uc3QgbWVzc2FnZSA9IGBKU09OIHJlcG9ydCBub3QgZm91bmQgYXQgJHt0aGlzLm91dHB1dFBhdGh9YDtcbiAgICAgICAgICAgIHRoaXMuZW1pdCgndGVybWluYWxFcnJvcicsIG1lc3NhZ2UpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBub1Rlc3RzRm91bmQgPSB0aGlzLmRvUmVzdWx0c0ZvbGxvd05vVGVzdHNGb3VuZE1lc3NhZ2UoKTtcbiAgICAgICAgICAgIHRoaXMuZW1pdCgnZXhlY3V0YWJsZUpTT04nLCBKU09OLnBhcnNlKF9kYXRhKSwge1xuICAgICAgICAgICAgICBub1Rlc3RzRm91bmQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnByZXZNZXNzYWdlVHlwZXMubGVuZ3RoID0gMDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIG1lc3NhZ2VUeXBlcy53YXRjaFVzYWdlOlxuICAgICAgY2FzZSBtZXNzYWdlVHlwZXMubm9UZXN0czpcbiAgICAgICAgdGhpcy5wcmV2TWVzc2FnZVR5cGVzLnB1c2gobXNnVHlwZSk7XG4gICAgICAgIHRoaXMuZW1pdCgnZXhlY3V0YWJsZVN0ZEVycicsIGRhdGEsIHtcbiAgICAgICAgICB0eXBlOiBtc2dUeXBlLFxuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICAvLyBubyBzcGVjaWFsIGFjdGlvbiBuZWVkZWQsIGp1c3QgcmVwb3J0IHRoZSBvdXRwdXQgYnkgaXRzIHNvdXJjZVxuICAgICAgICBpZiAoaXNTdGRFcnIpIHtcbiAgICAgICAgICB0aGlzLmVtaXQoJ2V4ZWN1dGFibGVTdGRFcnInLCBkYXRhLCB7XG4gICAgICAgICAgICB0eXBlOiBtc2dUeXBlLFxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuZW1pdCgnZXhlY3V0YWJsZU91dHB1dCcsIGRhdGEudG9TdHJpbmcoKS5yZXBsYWNlKCdcdTAwMWJbMkpcdTAwMWJbSCcsICcnKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wcmV2TWVzc2FnZVR5cGVzLmxlbmd0aCA9IDA7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHJldHVybiBtc2dUeXBlO1xuICB9XG5cbiAgcnVuSmVzdFdpdGhVcGRhdGVGb3JTbmFwc2hvdHMoY29tcGxldGlvbjogKCkgPT4gdm9pZCwgYXJncz86IHN0cmluZ1tdKSB7XG4gICAgY29uc3QgZGVmYXVsdEFyZ3MgPSBbJy0tdXBkYXRlU25hcHNob3QnXTtcblxuICAgIGNvbnN0IHVwZGF0ZVByb2Nlc3MgPSB0aGlzLl9jcmVhdGVQcm9jZXNzKHRoaXMud29ya3NwYWNlLCBbLi4uZGVmYXVsdEFyZ3MsIC4uLihhcmdzIHx8IFtdKV0pO1xuICAgIHVwZGF0ZVByb2Nlc3Mub24oJ2Nsb3NlJywgKCkgPT4ge1xuICAgICAgY29tcGxldGlvbigpO1xuICAgIH0pO1xuICB9XG5cbiAgY2xvc2VQcm9jZXNzKCkge1xuICAgIGlmICghdGhpcy5kZWJ1Z3Byb2Nlc3MgfHwgdGhpcy5fZXhpdGVkKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgY29uc29sZS5sb2coYHByb2Nlc3MgaGFzIG5vdCBzdGFydGVkIG9yIGFscmVhZHkgZXhpdGVkYCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChwcm9jZXNzLnBsYXRmb3JtID09PSAnd2luMzInKSB7XG4gICAgICAvLyBXaW5kb3dzIGRvZXNuJ3QgZXhpdCB0aGUgcHJvY2VzcyB3aGVuIGl0IHNob3VsZC5cbiAgICAgIHNwYXduKCd0YXNra2lsbCcsIFsnL3BpZCcsIGAke3RoaXMuZGVidWdwcm9jZXNzLnBpZH1gLCAnL1QnLCAnL0YnXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIGtpbGwgYWxsIHByb2Nlc3Mgd2l0aCB0aGUgc2FtZSBQR0lELCBpLmUuXG4gICAgICAgIC8vIGFzIGEgZGV0YWNoZWQgcHJvY2VzcywgaXQgaXMgdGhlIHNhbWUgYXMgdGhlIFBJRCBvZiB0aGUgbGVhZGVyIHByb2Nlc3MuXG4gICAgICAgIHByb2Nlc3Mua2lsbCgtdGhpcy5kZWJ1Z3Byb2Nlc3MucGlkKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gaWYgYW55dGhpbmcgZ29lcyB3cm9uZywgZmFsbGJhY2sgdG8gdGhlIG9sZCBiZW5hdmlvclxuICAgICAgICAvLyBrbm93aW5nIHRoaXMgY291bGQgbGVhdmUgb3JwaGFuIHByb2Nlc3MuLi5cbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgIGBmYWlsZWQgdG8ga2lsbCBwcm9jZXNzIGdyb3VwLCB0aGlzIGNvdWxkIGxlYXZlIHNvbWUgb3JwaGFuIHByb2Nlc3Mgd2hvc2UgcHBpZD0ke3RoaXMuZGVidWdwcm9jZXNzLnBpZH0uIGVycm9yPWAsXG4gICAgICAgICAgZVxuICAgICAgICApO1xuICAgICAgICB0aGlzLmRlYnVncHJvY2Vzcy5raWxsKCk7XG4gICAgICB9XG4gICAgfVxuICAgIGRlbGV0ZSB0aGlzLmRlYnVncHJvY2VzcztcbiAgfVxuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjbGFzcy1tZXRob2RzLXVzZS10aGlzXG4gIGZpbmRNZXNzYWdlVHlwZShidWY6IEJ1ZmZlcik6IE1lc3NhZ2VUeXBlIHtcbiAgICBjb25zdCBub1Rlc3RSZWdleCA9IC9ObyB0ZXN0cyBmb3VuZCByZWxhdGVkIHRvIGZpbGVzIGNoYW5nZWQgc2luY2UgKChsYXN0IGNvbW1pdCl8KFwiW2EtejAtOV0rXCIpKS4vO1xuICAgIGNvbnN0IHdhdGNoVXNhZ2VSZWdleCA9IC9eXFxzKldhdGNoIFVzYWdlXFxiLztcbiAgICBjb25zdCB0ZXN0UmVzdWx0c1JlZ2V4ID0gL1Rlc3QgcmVzdWx0cyB3cml0dGVuIHRvLztcblxuICAgIGNvbnN0IGNoZWNrcyA9IFtcbiAgICAgIHtyZWdleDogdGVzdFJlc3VsdHNSZWdleCwgbWVzc2FnZVR5cGU6IG1lc3NhZ2VUeXBlcy50ZXN0UmVzdWx0c30sXG4gICAgICB7cmVnZXg6IG5vVGVzdFJlZ2V4LCBtZXNzYWdlVHlwZTogbWVzc2FnZVR5cGVzLm5vVGVzdHN9LFxuICAgICAge3JlZ2V4OiB3YXRjaFVzYWdlUmVnZXgsIG1lc3NhZ2VUeXBlOiBtZXNzYWdlVHlwZXMud2F0Y2hVc2FnZX0sXG4gICAgXTtcblxuICAgIGNvbnN0IHN0ciA9IGJ1Zi50b1N0cmluZygndXRmOCcpO1xuICAgIGNvbnN0IG1hdGNoID0gY2hlY2tzLmZpbmQoKHtyZWdleH0pID0+IHJlZ2V4LnRlc3Qoc3RyKSk7XG4gICAgcmV0dXJuIG1hdGNoID8gbWF0Y2gubWVzc2FnZVR5cGUgOiBtZXNzYWdlVHlwZXMudW5rbm93bjtcbiAgfVxuXG4gIGRvUmVzdWx0c0ZvbGxvd05vVGVzdHNGb3VuZE1lc3NhZ2UoKSB7XG4gICAgaWYgKHRoaXMucHJldk1lc3NhZ2VUeXBlcy5sZW5ndGggPT09IDEpIHtcbiAgICAgIHJldHVybiB0aGlzLnByZXZNZXNzYWdlVHlwZXNbMF0gPT09IG1lc3NhZ2VUeXBlcy5ub1Rlc3RzO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnByZXZNZXNzYWdlVHlwZXMubGVuZ3RoID09PSAyKSB7XG4gICAgICByZXR1cm4gdGhpcy5wcmV2TWVzc2FnZVR5cGVzWzBdID09PSBtZXNzYWdlVHlwZXMubm9UZXN0cyAmJiB0aGlzLnByZXZNZXNzYWdlVHlwZXNbMV0gPT09IG1lc3NhZ2VUeXBlcy53YXRjaFVzYWdlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuIl19